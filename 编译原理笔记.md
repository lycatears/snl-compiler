# NFA到DFA的转换

## ε闭包

已知一个NFA（非确定有限状态机）M，M的状态集中有一个子集I，则I的ε闭包为：

$\epsilon \_CLOSURE(I)$

1. 所有I中的状态q，都属于$\epsilon \_CLOSURE(I)$，即对于$\forall q\in I,q\in \epsilon \_CLOSURE(I)$；

2. 对于所有I中的状态q，q经过任意条空边所能到达的状态都属于$\epsilon \_CLOSURE(I)$。

## 状态集I的a转换

假设上述$I=\{S_0,S_1,\dots,S_m\}$，有字母表中的字符$a\in \sum$，定义状态集I的a转换为：

$I_a=\epsilon\_CLOSURE(J)$，其中$J=f(S_0,a)\cup f(S_1,a) \dots \cup f(S_m,a)$

也就是说求I的a转换，首先要将所有I中的单个状态走一条a边，就是把状态$S_i$替换为$S_i$经过它上面连着的所有a边，所能到达的状态的集合。当然如果没有a边就不用替换了，直接就是空集了。将状态集里面的所有状态都做一次上面的变换，把这些集合取并集，然后求这个并集的ε闭包，就是我们要求的答案了。

## NFA到DFA转换算法

1. 令$I_0=\epsilon \_CLOSURE(S_0)$ 作为DFA的初始状态，其中$S_0$为初始状态集。$I_0$即为DFA的初始状态。

2. 如果DFA中所有状态均经过本步骤处理，则转到3。否则任选一个未经过本步骤处理的DFA状态$S_i$，对于所有字母表中的状态$a\in \sum$，作如下处理：
   2.1 计算$S_i$的a转换$S_{ia}$（求$S_i$在NFA中的所有状态的a转换的并集）
   2.2 如果$S_{ia}\neq \Phi$，则令$f(S_i,a)=S_j$，如果不存在$S_j$，则作为一个新状态加入到DFA中。

3. 对于所有DFA状态，如果其代表的原NFA中的状态集含有终止状态，则该状态是DFA的一个终止状态。

# DFA化简

## 等价状态

对于一个DFA M的两个状态$S_1,S_2$，对于任意输入的符号串，从$S_i$和$S_2$出发，总是都到达接收状态或者终止状态，则二者等价。

例如：

$2\stackrel{b}{\longrightarrow}3\stackrel{c}{\longrightarrow}4^-$

$5\stackrel{b}{\longrightarrow}6\stackrel{c}{\longrightarrow}7^-$

此时2,5两个状态是等价状态

## 无关状态

从起始状态没有到这个状态的路径，或者这个状态没有到终止状态的路径，就是无关状态。

## 自动机的最小化

没有无关状态和等价状态的DFA是最小DFA。

任一DFA都存在等价的最小DFA。

## 状态分离法

目标：将DFA中的所有状态划分为一系列等价状态的集合，即：

$SS=SS_1\cup SS_2 \cup \dots \cup SS_n$，其中$SS_i \cap SS_j=\Phi(i\neq j)$.

 对a不可区分、可区分：$SS_i$中的各个状态对输入字符a转移到相同/不同的状态集。

对a进行划分：$SS_i$中元素对于输入符a转移到不同状态集中，分别将转移到相同集合的状态各组成一个状态集。

算法：

1. 初始划分：将整个状态集划分为非终止状态集和终止状态集两个子集。

2. 如果整个状态集中的每个子集，对于任意输入字符a都是不可区分的，则转移到步骤3。否则对可区分的子集，根据相应的输入字符a进行划分，循环执行本步骤。

3. 每个子集合并为一个状态，包含初态的集合为初态，包含任意终止状态的集合合并为终止状态。

# 文法、语言、短语、句型

## 语法分析简述

语法分析是编译程序的核心，在token序列的基础上分析源代码是否符合语法。

语言的语法用上下文无关文法描述，语法分析的任务就是用上下文无关文法判断token序列是否构成语法正确的程序，分为自顶向下、自底向上。

## 文法与语言

文法是程序语言的生成系统，文法能够精确定义一个语言，并依据文法构造识别该语言的自动机。

- 词法用正则语言描述（3型文法）

- 语法用上下文无关文法描述（2型文法）

- 语义用上下文有关文法描述（1型文法）

语言的三个基本要素：语法、语义、语用

### 语言

对于字母表$\sum$，$\sum^*$表示字母表上的所有字符串，$\sum^*$的任意子集表示字母表上的一个语言$L$，$L$中的任意一个字符串都是语言的一个句子，也就是语句。

### 文法

文法由一个四元组确定，$G=(V_T,V_N,S,P)$

- $V_T$表示终极符，一般用小写字母表示终极符，每个token就是一个终极符，终极符是语法上一个语言不可再分的基本符号。

- $V_N$表示非终极符，一般用大写字母表示非终极符。终极符表示一个语法范畴，表示一类具有某种性质的符号，例如”表达式“就是一个非终极符。

- $S$是开始符号，是一个特殊的非终极符。

- $P$是产生式的有限集合，是定义语法的文法规则。

- 设$V$是语法$G$的符号集，则有：$V=V_T\cup V_N,V_T\cap V_N=\emptyset$

### 产生式

形式：$\alpha \to \beta$

当左部仅含一个非终极符时，称为上下文无关文法。$\alpha\in(V_T\cup V_N)^+,\beta\in(V_T\cup V_N)^*$

$P \to \alpha_1,P \to \alpha_2,\dots,P \to \alpha_n$可以写作$P\to \alpha_1|\alpha_2|\dots|\alpha_n$



# First Follow Predict集合的计算

## First集合计算

对于符号$X$：

- 如果$X$是终极符，那么$X$的First集合就是$X$本身组成的单元素集合，即：$First(X)=\{X\}$

- 如果$X$是非终极符：
  
  - 检查$X$的所有产生式，对于右部以终极符开头的，将这个打头的终极符添加到$X$的First集合中。即：$First(X)=\{a|X\to a\dots\in P,a\in V_T\}$
  
  - 如果有产生式$X\to \epsilon$，则将$\epsilon$添加到$X$的First集中。
  
  - 对于产生式$X\to Y_1Y_2\dots Y_n$，且有$Y_1,Y_2,\dots ,Y_n\in V_N$ （也就是右部是几个非终极符的情况）：
    
    - 如果这些非终极符都有导向空串的产生式，那么把所有$First(Y_i)$的并集添加到$First(X)$中
    
    - 如果在其中某一个$Y_i$出现了不能导向空串的非终极符，那么把从$Y_1$到$Y_{i-1}$的所有非终极符的First集除去空串后的集合，以及$Y_i$的First集，求并集，添加到$X$的First集中。

## Follow集合计算

- 对于所有非终极符（开始符号除外）$A\in V_N$，设其Follow集合为空集，即$Follow(A)=\{\}$
  而对于开始符号$S$，有$Follow(S)=\{\#\}$

- 对于所有产生式$A\to xBy$：
  
  - 若$\epsilon\in First(y)$，则将$(First(y)-\{\epsilon\})\cup Follow(A)$的所有元素添加到$Follow(B)$中，也就是：$Follow(B)=Follow(B)\cup (First(y)-{\epsilon})\cup Follow(A)$
  
  - 若$\epsilon \notin First(y)$，则将$First(y)$的所有元素添加到$Follow(B)$，也就是：$Follow(B)=Follow(B)\cup First(y)$

- 循环执行第二步，直到收敛。

## Predict集合计算

- 对于每一条产生式，如果右部的first不含空串，则predict为右部的first，否则为右部的first（去掉空串）与左部的follow的并集。

## LL(1)文法

- 对于相同左部的任意两个产生式，predict集的交集为空，则为LL(1)文法。LL(1)文法与递归下降文法的判断标准相同。

- 非确定的自顶向下语法分析效率低，是因为虚假匹配造成回溯。
  
  - 右部first交集不为空
  
  - 右部能推导出空串，follow含有某个产生式左部的first中的元素

## 预测分析表

预测分析表是非终极符遇到某个终极符使用产生式的函数定义，即$T:V_N\times V_T \to P \cup \{Error\}$

若$t\in Predict(A\to \alpha)$则$T(A,t)=\alpha$，否则$T(A,t)=Error$

## LL(1)分析过程

需要一个栈和一个token输入流，栈初始化为$[\#,S]$，输入流初始化为$[a_1,a_2,\dots,a_n,\#]$，称为初始格局。符号栈和输入流合称分析格局。

- 栈顶为终极符，则匹配输入流的第一个字符，匹配成功则弹出栈顶元素和输入流首个元素（消消乐），否则出错。

- 栈顶为非终极符，弹出该栈顶元素，将匹配（根据输入流首字符和非终极符，与LL(1)分析表相匹配）的产生式逆序压入栈。例如$A\to X_1X_2X_3$，当前格局为$[\#,A]$，则匹配后为$[\#,X_3,X_2,X_1]$。如果没有匹配的产生式，出错。

- 当前格局为$[\#],[\#]$时，分析成功结束。

## 文法等价变换

- 左公共前缀（简称乘法分配律）
  $A\to \alpha\beta_1|\alpha\beta_2|\dots|\alpha\beta_n|\gamma_1|\gamma_2|\dots|\gamma_m$
  变换为：$A\to \alpha A'|\gamma_1|\gamma_2|\dots|\gamma_m$
  $A'\to \beta_1|\beta_2|\dots|\beta_n$

- 消除直接左递归
  $A\to A\alpha_1|A\alpha_2|\dots|A\alpha_n|\beta_1|\beta_2|\dots|\beta_m$
  变换为：
  $A\to (\beta_1|\beta_2|\dots|\beta_m)A'$
  $A'\to (\alpha_1|\alpha_2|\dots|\alpha_n)A|\epsilon$
  其实就是左递归变成右递归。

- 消除间接左递归
  首先给左部的非终极符排序（PPT没有说用什么排序），然后根据这个排序，对产生式进行替换，每个产生式的右部出现的终极符只能是排在左部后面的，最后化为直接左递归。

## LL(1)与递归下降的对比

- 相同点：都需要LL(1)文法，都是自顶向下语法分析

- 不同点：递归下降法实现较为简单，LL(1)较复杂；递归下降法运行效率较低，一般只用于研究，实际的编译程序几乎不用；文法发生变化时，LL(1)只需要修改预测分析表，递归下降法需要修改程序。

# 语义分析

## 基本概念

- 语言四个内容：词法（允许出现的单词、单词构成的规则）、语法（什么样的字符串是合法程序）、语义（结构上合法的程序的意义法则）、语用。

- 常见语义错误
  
  - 静态语义：编译时可以检查到的语义错误。例如标识符未使用先调用、重复声明，变量当作函数调用。
  
  - 动态语义：目标程序运行时才能检查，例如除零溢出、下标越界等。
  
  - 编译程序只能进行静态语义检查。

- 语义分析的任务
  
  - 建立符号表
    编译器保存源程序信息的数据结构，每个条目包含与标识符有关系的信息，反应标识符的属性以及在编译中的特征。作用：保存标识符属性；检查语义错误；作为后续代码生成阶段分配地址的基础。
  
  - 检查语义错误

- 错误检查
  
  - 声明性出现
    如果已有该符号，则是重复声明错误。否则加入符号表
  
  - 使用性出现
    如果符号表没有该符号，则是未声明错误。如果找到则进行后续分析

## 标识符的内部表示

- 标识符常见属性
  Name(名称)
  Kind(种类，这个种类是指常量、变量、函数、类型标识符等)
  Type(指向类型的指针，程序设计语言的数据类型，如整型、浮点型、字符型、数组、指针、枚举、结构体等)
  Value(指向常量值内部表示的指针)
  特有信息，如数组的上下界、元素类型，函数的参数表、返回类型、传参方式

- 常量：例如，浮点型常量`const pi = 3.14`:Name=pi,Kind=constKind,Type=realPtr,Value=↑<3.14>

- 变量：
  
  | Name | Kind    | Type                    | Access             | Level | Off              | Value          |
  | ---- | ------- | ----------------------- | ------------------ | ----- | ---------------- | -------------- |
  | 变量名称 | VarKind | 指向类型的指针，如intPtr,realPtr | indir/dir，直接/非直接变量 | 层数    | 相对于过程、函数、主程序的偏移量 | 指向值的指针，可以为NULL |
  
  ```c
  int x=10;
  float y,*z;
  ```
  
  内部表示为：
  
  x,varkind,intPtr,dir,L,off+0,↑<10>
  
  y,varkind,realPtr,dir,L,off+1,NULL
  
  z,varkind,pointptr(指向类型符号：pointTy,realPtr),indir,off+3,NULL

- 类型标识符：
  
  ```c
  typedef int t1;
  typedef int t2 [10];
  ```
  
  | Name | Kind     | Type          |
  | ---- | -------- | ------------- |
  | 名称   | TypeKind | 指向具体类型内部表示的指针 |
  
  $(t1,typeKind,intPtr\to (size=1,Kind=intTy))$
  
  $(t2,typeKind,ptr\to (size=10,Kind=ArrayTy,Low=0,Up=9,ElemType\to(size=1,Kind=intTy)))$

- 函数：
  
  | Name | Kind     | Type     | Level | off                        | Param                        | Class                           | Code                                       | Size                          | Forward                                |
  | ---- | -------- | -------- | ----- | -------------------------- | ---------------------------- | ------------------------------- | ------------------------------------------ | ----------------------------- | -------------------------------------- |
  | 函数名称 | routKind | 返回值类型的指针 | 层数    | 偏移量，仅对形式函数有效，表示该形式函数所在块的层数 | 参数表指针，与变量符号表结构相同(但没有指向具体值的域) | actual=实在函数，formal=形式函数（作为参数传递） | 仅对实在函数有效，指向函数代码区起始地址。目标代码生成后回填，对于形式函数为NULL | 仅对实在函数有效，表示过程活动记录大小，目标代码生成后回填 | true/false，仅对实在函数有效，表示是否为超前声明（如C的函数原型） |
  
  ```pascal
  function f(x：integer；var y：real；
  function inc(a：integer)：integer)：integer；// "头"
   // ......f的函数体部分
  end；
  ```
  
  $(Name=f,Kind=routKind,Type=intPtr,Level=L,off=NULL,Param,Class=actual,Code=NULL,Size=NULL,forward=false)$
  
  $Param\to [(x,varKind,intPtr,dir,L+1,off_0)\to (y,varkind,pointPtr(pointPtr,realTy),indir,L+1,off_0+1)\to (inc,routKind,intPtr,L+1,off_0+2,[(a,varKind,intPtr,dir,L+2,off_1)],formal,NULL,NULL,NULL)]$
  
  注：上面的浮点数是指针，认为占1字长

- 类型内部表示
  
  - 标准类型：大小+种类(size,kind)
    
    $intPtr\to(1,intTy)$
    
    $realPtr\to(2,intTy)$
  
  - 数组类型：大小（size，对于多维数组，是指总大小）,种类（kind=ArrayTy）,下界（low），上界（up），类型指针（ElemType）
    
    ```c
    typedef int A[10];
    typedef char B [5][10];
    ```
    
    $A\to(10,ArrayTy,0,9,intPtr)$
    
    $B\to (50,ArrayTy,0,4,ptr\to(10,ArrayTy,0,9,CharTy))$
  
  - 结构体：大小（size），种类（kind=StructTy），字段链指针（RecBody）
    
    ```c
    typedef struct Date 
    {int year, month, day;} datetype;
    ```
    
    $datetype\to(3,structTy,ptr\to[(Name=year,Type=intPtr,off=0,link)\to (month,intPtr,1,link)\to(day,intPtr,2,NULL)])$
    
    共用体与此相似，只不过kind=unionTy，没有size、off字段。
  
  - 指针：大小（size=1），种类（kind=pointTy），指向类型（BaseType）
    
    ```c
    typedef  int* T1;
    ```
    
    $T1\to(1,pointTy,intPtr)$
  
  - 枚举：大小（size=1），种类（kind=EnumTy），枚举列表（ElemList）
    
    ```c
    enum color {red=10, yellow=red+2, blue}
    ```
    
    $color\to(1,enumTy,ElemList\to[(Name=red,value=10),(yellow,12),(blue,13)])$

## 抽象地址与符号表

- 存储空间分配
  
  静态分配是编译时为程序所有数据对象分配固定地址，运行时始终保持不变，较为直观，但不支持动态申请空间。动态分配则为程序数据分配抽象地址，程序运行时再分配具体地址。

- 过程活动记录
  
  每次函数调用时会为函数分配空间，存储管理信息、形参、局部变量、临时变量等信息，称为过程活动记录（AR），偏移量就是针对AR的，起始位置+偏移量=物理位置。AR存储的顺序，就是处理的先后次序。

- 层数
  
  嵌套式语言，主程序为0，主程序直接定义的函数为1层。若某函数为L层，则该函数内部定义的函数为L+1层。对于并列式语言，全局为0层，所有函数为0层，函数内的变量为1层。

- 抽象地址
  
  抽象地址包括层数、偏移量两个字段，主要针对嵌套式语言，表示某个函数所处的层数，偏移量是针对AR的相对偏移量。

- 空间分配
  
  临时变量、地址引用为1个单元，值传递、局部变量按照该类型大小，函数形参分配2个（入口和Display表）

- 符号表的作用
  
  语义分析阶段，用于语义检查；中间代码生成阶段，用于类型检查、强制类型转换；目标代码生成阶段，作为地址分配的依据。（总体组织：根据类型分为单表？多表？表项排列：顺序？散列？有序表？局部化：全局？局部？）
  
  符号表存储标识符的语义信息，包括名称、语义字（名称、抽象地址、类型等）
  
  多表结构是将属性相同的放在一个表中，例如常量表、变量表、类型表等。优点是各表中的表项相同、等长，所有属性有效，管理方便、一致，空间利用率高。缺点是同时管理多个符号表，增加了工作量和复杂度，需要对共同属性设置重复管理机制，造成冗余。
  
  单表结构是所有符号都在一个符号表中，优点是结构单一、管理方便，不同种类的符号可以一致管理。缺点是表项不等长，属性位置可能交错重叠，增加了管理复杂度。可以将所有可能的属性都作为符号表属性，有助于降低复杂度，但是会降低空间利用率。
  
  折中方式则是将几类符号依据属性相似程度分组，每张表中有较多的相同属性。

- 局部化处理
  
  全局式符号表是把整个程序的符号表作为一个表，局部式符号表是指把每个局部化单位的符号表作为一个独立的表来处理。

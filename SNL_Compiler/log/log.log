2019-06-21 08:00:35.043 [INFO ] com.mytlx.compiler.GUI.SNLCompilerGUI - =======开始语法分析========
2019-06-21 08:00:35.043 [INFO ] com.mytlx.compiler.GUI.SNLCompilerGUI - 源文件：./src/main/resources/tmp/snlText.txt
2019-06-21 08:00:35.043 [INFO ] com.mytlx.compiler.GUI.SNLCompilerGUI - 输出文件：./src/main/resources/tmp/syntaxTree.txt
2019-06-21 08:00:35.043 [INFO ] com.mytlx.compiler.GUI.SNLCompilerGUI - ===========================
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 调用getToken方法
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："p"(112)[1:1]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入NORMAL状态
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："r"(114)[1:2]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："o"(111)[1:3]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："g"(103)[1:4]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："r"(114)[1:5]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："a"(97)[1:6]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："m"(109)[1:7]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是：" "(32)[1:8]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符已经不是标识符范围的了：" "(32)[1:8]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 回溯字符：" "(32)[1:8]
2019-06-21 08:00:36.261 [DEBUG] com.mytlx.compiler.lexer.Lexer - 已识别Token：< (1,7), PROGRAM, program >
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 调用getToken方法
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："s"(115)[1:9]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入NORMAL状态
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："d"(100)[1:10]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："\n"(10)[1:11]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符已经不是标识符范围的了："\n"(10)[1:11]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 回溯字符："\n"(10)[1:11]
2019-06-21 08:00:36.261 [DEBUG] com.mytlx.compiler.lexer.Lexer - 已识别Token：< (1,10), ID, sd >
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 调用getToken方法
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："v"(118)[2:1]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入NORMAL状态
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："a"(97)[2:2]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："r"(114)[2:3]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是：" "(32)[2:4]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符已经不是标识符范围的了：" "(32)[2:4]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 回溯字符：" "(32)[2:4]
2019-06-21 08:00:36.261 [DEBUG] com.mytlx.compiler.lexer.Lexer - 已识别Token：< (2,3), VAR, var >
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 调用getToken方法
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："i"(105)[2:5]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入NORMAL状态
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："n"(110)[2:6]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："t"(116)[2:7]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："e"(101)[2:8]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："g"(103)[2:9]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："e"(101)[2:10]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："r"(114)[2:11]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是：" "(32)[2:12]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符已经不是标识符范围的了：" "(32)[2:12]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 回溯字符：" "(32)[2:12]
2019-06-21 08:00:36.261 [DEBUG] com.mytlx.compiler.lexer.Lexer - 已识别Token：< (2,11), INTEGER, integer >
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 调用getToken方法
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："s"(115)[2:13]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入NORMAL状态
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是：";"(59)[2:14]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符已经不是标识符范围的了：";"(59)[2:14]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 回溯字符：";"(59)[2:14]
2019-06-21 08:00:36.261 [DEBUG] com.mytlx.compiler.lexer.Lexer - 已识别Token：< (2,13), ID, s >
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 调用getToken方法
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是：";"(59)[2:14]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入NORMAL状态
2019-06-21 08:00:36.261 [DEBUG] com.mytlx.compiler.lexer.Lexer - 已识别Token：< (2,14), SEMI, ; >
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 调用getToken方法
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："\n"(10)[2:15]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入NORMAL状态
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是：" "(32)[3:1]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入NORMAL状态
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是：" "(32)[3:2]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入NORMAL状态
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是：" "(32)[3:3]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入NORMAL状态
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是：" "(32)[3:4]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入NORMAL状态
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："i"(105)[3:5]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入NORMAL状态
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："n"(110)[3:6]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："t"(116)[3:7]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："e"(101)[3:8]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："g"(103)[3:9]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："e"(101)[3:10]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："r"(114)[3:11]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是：" "(32)[3:12]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符已经不是标识符范围的了：" "(32)[3:12]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 回溯字符：" "(32)[3:12]
2019-06-21 08:00:36.261 [DEBUG] com.mytlx.compiler.lexer.Lexer - 已识别Token：< (3,11), INTEGER, integer >
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 调用getToken方法
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："t"(116)[3:13]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入NORMAL状态
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是：";"(59)[3:14]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符已经不是标识符范围的了：";"(59)[3:14]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 回溯字符：";"(59)[3:14]
2019-06-21 08:00:36.261 [DEBUG] com.mytlx.compiler.lexer.Lexer - 已识别Token：< (3,13), ID, t >
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 调用getToken方法
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是：";"(59)[3:14]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入NORMAL状态
2019-06-21 08:00:36.261 [DEBUG] com.mytlx.compiler.lexer.Lexer - 已识别Token：< (3,14), SEMI, ; >
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 调用getToken方法
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："\n"(10)[3:15]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入NORMAL状态
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："p"(112)[4:1]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入NORMAL状态
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："r"(114)[4:2]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："o"(111)[4:3]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："c"(99)[4:4]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："e"(101)[4:5]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："d"(100)[4:6]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："u"(117)[4:7]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："r"(114)[4:8]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："e"(101)[4:9]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是：" "(32)[4:10]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符已经不是标识符范围的了：" "(32)[4:10]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 回溯字符：" "(32)[4:10]
2019-06-21 08:00:36.261 [DEBUG] com.mytlx.compiler.lexer.Lexer - 已识别Token：< (4,9), PROCEDURE, procedure >
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 调用getToken方法
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："f"(102)[4:11]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入NORMAL状态
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："a"(97)[4:12]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："c"(99)[4:13]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："t"(116)[4:14]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："o"(111)[4:15]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："r"(114)[4:16]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："("(40)[4:17]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符已经不是标识符范围的了："("(40)[4:17]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 回溯字符："("(40)[4:17]
2019-06-21 08:00:36.261 [DEBUG] com.mytlx.compiler.lexer.Lexer - 已识别Token：< (4,16), ID, factor >
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 调用getToken方法
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："("(40)[4:17]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入NORMAL状态
2019-06-21 08:00:36.261 [DEBUG] com.mytlx.compiler.lexer.Lexer - 已识别Token：< (4,17), LPAREN, ( >
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 调用getToken方法
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："i"(105)[4:18]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入NORMAL状态
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："n"(110)[4:19]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："t"(116)[4:20]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："e"(101)[4:21]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："g"(103)[4:22]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："e"(101)[4:23]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："r"(114)[4:24]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是：" "(32)[4:25]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符已经不是标识符范围的了：" "(32)[4:25]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 回溯字符：" "(32)[4:25]
2019-06-21 08:00:36.261 [DEBUG] com.mytlx.compiler.lexer.Lexer - 已识别Token：< (4,24), INTEGER, integer >
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 调用getToken方法
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："n"(110)[4:26]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入NORMAL状态
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是：";"(59)[4:27]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符已经不是标识符范围的了：";"(59)[4:27]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 回溯字符：";"(59)[4:27]
2019-06-21 08:00:36.261 [DEBUG] com.mytlx.compiler.lexer.Lexer - 已识别Token：< (4,26), ID, n >
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 调用getToken方法
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是：";"(59)[4:27]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入NORMAL状态
2019-06-21 08:00:36.261 [DEBUG] com.mytlx.compiler.lexer.Lexer - 已识别Token：< (4,27), SEMI, ; >
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 调用getToken方法
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："v"(118)[4:28]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入NORMAL状态
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："a"(97)[4:29]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："r"(114)[4:30]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是：" "(32)[4:31]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符已经不是标识符范围的了：" "(32)[4:31]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 回溯字符：" "(32)[4:31]
2019-06-21 08:00:36.261 [DEBUG] com.mytlx.compiler.lexer.Lexer - 已识别Token：< (4,30), VAR, var >
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 调用getToken方法
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："i"(105)[4:32]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入NORMAL状态
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："n"(110)[4:33]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："t"(116)[4:34]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："e"(101)[4:35]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："g"(103)[4:36]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："e"(101)[4:37]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："r"(114)[4:38]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是：" "(32)[4:39]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符已经不是标识符范围的了：" "(32)[4:39]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 回溯字符：" "(32)[4:39]
2019-06-21 08:00:36.261 [DEBUG] com.mytlx.compiler.lexer.Lexer - 已识别Token：< (4,38), INTEGER, integer >
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 调用getToken方法
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："m"(109)[4:40]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入NORMAL状态
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是：")"(41)[4:41]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符已经不是标识符范围的了：")"(41)[4:41]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 回溯字符：")"(41)[4:41]
2019-06-21 08:00:36.261 [DEBUG] com.mytlx.compiler.lexer.Lexer - 已识别Token：< (4,40), ID, m >
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 调用getToken方法
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是：")"(41)[4:41]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入NORMAL状态
2019-06-21 08:00:36.261 [DEBUG] com.mytlx.compiler.lexer.Lexer - 已识别Token：< (4,41), RPAREN, ) >
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 调用getToken方法
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是：";"(59)[4:42]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入NORMAL状态
2019-06-21 08:00:36.261 [DEBUG] com.mytlx.compiler.lexer.Lexer - 已识别Token：< (4,42), SEMI, ; >
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 调用getToken方法
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："\n"(10)[4:43]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入NORMAL状态
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："v"(118)[5:1]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入NORMAL状态
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："a"(97)[5:2]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："r"(114)[5:3]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是：" "(32)[5:4]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符已经不是标识符范围的了：" "(32)[5:4]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 回溯字符：" "(32)[5:4]
2019-06-21 08:00:36.261 [DEBUG] com.mytlx.compiler.lexer.Lexer - 已识别Token：< (5,3), VAR, var >
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 调用getToken方法
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："i"(105)[5:5]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入NORMAL状态
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："n"(110)[5:6]
2019-06-21 08:00:36.261 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："t"(116)[5:7]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："e"(101)[5:8]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："g"(103)[5:9]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："e"(101)[5:10]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："r"(114)[5:11]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是：" "(32)[5:12]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符已经不是标识符范围的了：" "(32)[5:12]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 回溯字符：" "(32)[5:12]
2019-06-21 08:00:36.277 [DEBUG] com.mytlx.compiler.lexer.Lexer - 已识别Token：< (5,11), INTEGER, integer >
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 调用getToken方法
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："w"(119)[5:13]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入NORMAL状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是：";"(59)[5:14]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符已经不是标识符范围的了：";"(59)[5:14]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 回溯字符：";"(59)[5:14]
2019-06-21 08:00:36.277 [DEBUG] com.mytlx.compiler.lexer.Lexer - 已识别Token：< (5,13), ID, w >
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 调用getToken方法
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是：";"(59)[5:14]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入NORMAL状态
2019-06-21 08:00:36.277 [DEBUG] com.mytlx.compiler.lexer.Lexer - 已识别Token：< (5,14), SEMI, ; >
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 调用getToken方法
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："\n"(10)[5:15]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入NORMAL状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："b"(98)[6:1]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入NORMAL状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："e"(101)[6:2]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："g"(103)[6:3]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："i"(105)[6:4]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："n"(110)[6:5]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："\n"(10)[6:6]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符已经不是标识符范围的了："\n"(10)[6:6]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 回溯字符："\n"(10)[6:6]
2019-06-21 08:00:36.277 [DEBUG] com.mytlx.compiler.lexer.Lexer - 已识别Token：< (6,5), BEGIN, begin >
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 调用getToken方法
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："i"(105)[7:1]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入NORMAL状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："f"(102)[7:2]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是：" "(32)[7:3]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符已经不是标识符范围的了：" "(32)[7:3]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 回溯字符：" "(32)[7:3]
2019-06-21 08:00:36.277 [DEBUG] com.mytlx.compiler.lexer.Lexer - 已识别Token：< (7,2), IF, if >
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 调用getToken方法
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："n"(110)[7:4]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入NORMAL状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："="(61)[7:5]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符已经不是标识符范围的了："="(61)[7:5]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 回溯字符："="(61)[7:5]
2019-06-21 08:00:36.277 [DEBUG] com.mytlx.compiler.lexer.Lexer - 已识别Token：< (7,4), ID, n >
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 调用getToken方法
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："="(61)[7:5]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入NORMAL状态
2019-06-21 08:00:36.277 [DEBUG] com.mytlx.compiler.lexer.Lexer - 已识别Token：< (7,5), EQ, = >
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 调用getToken方法
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："0"(48)[7:6]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入NORMAL状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："\n"(10)[7:7]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入NUM状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 回溯字符："\n"(10)[7:7]
2019-06-21 08:00:36.277 [DEBUG] com.mytlx.compiler.lexer.Lexer - 已识别Token：< (7,6), INTC, 0 >
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 调用getToken方法
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："t"(116)[8:1]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入NORMAL状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："h"(104)[8:2]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："e"(101)[8:3]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："n"(110)[8:4]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是：" "(32)[8:5]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符已经不是标识符范围的了：" "(32)[8:5]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 回溯字符：" "(32)[8:5]
2019-06-21 08:00:36.277 [DEBUG] com.mytlx.compiler.lexer.Lexer - 已识别Token：< (8,4), THEN, then >
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 调用getToken方法
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："m"(109)[8:6]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入NORMAL状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是：":"(58)[8:7]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符已经不是标识符范围的了：":"(58)[8:7]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 回溯字符：":"(58)[8:7]
2019-06-21 08:00:36.277 [DEBUG] com.mytlx.compiler.lexer.Lexer - 已识别Token：< (8,6), ID, m >
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 调用getToken方法
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是：":"(58)[8:7]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入NORMAL状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："="(61)[8:8]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ASSIGN状态
2019-06-21 08:00:36.277 [DEBUG] com.mytlx.compiler.lexer.Lexer - 已识别Token：< (8,8), ASSIGN, := >
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 调用getToken方法
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："1"(49)[8:9]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入NORMAL状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："\n"(10)[8:10]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入NUM状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 回溯字符："\n"(10)[8:10]
2019-06-21 08:00:36.277 [DEBUG] com.mytlx.compiler.lexer.Lexer - 已识别Token：< (8,9), INTC, 1 >
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 调用getToken方法
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："e"(101)[9:1]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入NORMAL状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："l"(108)[9:2]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："s"(115)[9:3]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："e"(101)[9:4]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是：" "(32)[9:5]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符已经不是标识符范围的了：" "(32)[9:5]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 回溯字符：" "(32)[9:5]
2019-06-21 08:00:36.277 [DEBUG] com.mytlx.compiler.lexer.Lexer - 已识别Token：< (9,4), ELSE, else >
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 调用getToken方法
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："\n"(10)[9:6]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入NORMAL状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是：" "(32)[10:1]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入NORMAL状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是：" "(32)[10:2]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入NORMAL状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："f"(102)[10:3]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入NORMAL状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："a"(97)[10:4]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："c"(99)[10:5]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："t"(116)[10:6]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："o"(111)[10:7]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："r"(114)[10:8]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："("(40)[10:9]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符已经不是标识符范围的了："("(40)[10:9]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 回溯字符："("(40)[10:9]
2019-06-21 08:00:36.277 [DEBUG] com.mytlx.compiler.lexer.Lexer - 已识别Token：< (10,8), ID, factor >
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 调用getToken方法
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："("(40)[10:9]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入NORMAL状态
2019-06-21 08:00:36.277 [DEBUG] com.mytlx.compiler.lexer.Lexer - 已识别Token：< (10,9), LPAREN, ( >
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 调用getToken方法
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："n"(110)[10:10]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入NORMAL状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："-"(45)[10:11]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符已经不是标识符范围的了："-"(45)[10:11]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 回溯字符："-"(45)[10:11]
2019-06-21 08:00:36.277 [DEBUG] com.mytlx.compiler.lexer.Lexer - 已识别Token：< (10,10), ID, n >
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 调用getToken方法
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："-"(45)[10:11]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入NORMAL状态
2019-06-21 08:00:36.277 [DEBUG] com.mytlx.compiler.lexer.Lexer - 已识别Token：< (10,11), MINUS, - >
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 调用getToken方法
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："1"(49)[10:12]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入NORMAL状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是：","(44)[10:13]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入NUM状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 回溯字符：","(44)[10:13]
2019-06-21 08:00:36.277 [DEBUG] com.mytlx.compiler.lexer.Lexer - 已识别Token：< (10,12), INTC, 1 >
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 调用getToken方法
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是：","(44)[10:13]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入NORMAL状态
2019-06-21 08:00:36.277 [DEBUG] com.mytlx.compiler.lexer.Lexer - 已识别Token：< (10,13), COMMA, , >
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 调用getToken方法
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："w"(119)[10:14]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入NORMAL状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是：")"(41)[10:15]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符已经不是标识符范围的了：")"(41)[10:15]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 回溯字符：")"(41)[10:15]
2019-06-21 08:00:36.277 [DEBUG] com.mytlx.compiler.lexer.Lexer - 已识别Token：< (10,14), ID, w >
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 调用getToken方法
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是：")"(41)[10:15]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入NORMAL状态
2019-06-21 08:00:36.277 [DEBUG] com.mytlx.compiler.lexer.Lexer - 已识别Token：< (10,15), RPAREN, ) >
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 调用getToken方法
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是：";"(59)[10:16]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入NORMAL状态
2019-06-21 08:00:36.277 [DEBUG] com.mytlx.compiler.lexer.Lexer - 已识别Token：< (10,16), SEMI, ; >
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 调用getToken方法
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："\n"(10)[10:17]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入NORMAL状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是：" "(32)[11:1]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入NORMAL状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是：" "(32)[11:2]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入NORMAL状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："m"(109)[11:3]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入NORMAL状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是：":"(58)[11:4]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符已经不是标识符范围的了：":"(58)[11:4]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 回溯字符：":"(58)[11:4]
2019-06-21 08:00:36.277 [DEBUG] com.mytlx.compiler.lexer.Lexer - 已识别Token：< (11,3), ID, m >
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 调用getToken方法
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是：":"(58)[11:4]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入NORMAL状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："="(61)[11:5]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ASSIGN状态
2019-06-21 08:00:36.277 [DEBUG] com.mytlx.compiler.lexer.Lexer - 已识别Token：< (11,5), ASSIGN, := >
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 调用getToken方法
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："n"(110)[11:6]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入NORMAL状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："*"(42)[11:7]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符已经不是标识符范围的了："*"(42)[11:7]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 回溯字符："*"(42)[11:7]
2019-06-21 08:00:36.277 [DEBUG] com.mytlx.compiler.lexer.Lexer - 已识别Token：< (11,6), ID, n >
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 调用getToken方法
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："*"(42)[11:7]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入NORMAL状态
2019-06-21 08:00:36.277 [DEBUG] com.mytlx.compiler.lexer.Lexer - 已识别Token：< (11,7), TIMES, * >
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 调用getToken方法
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："w"(119)[11:8]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入NORMAL状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："\n"(10)[11:9]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符已经不是标识符范围的了："\n"(10)[11:9]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 回溯字符："\n"(10)[11:9]
2019-06-21 08:00:36.277 [DEBUG] com.mytlx.compiler.lexer.Lexer - 已识别Token：< (11,8), ID, w >
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 调用getToken方法
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："f"(102)[12:1]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入NORMAL状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："i"(105)[12:2]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："\n"(10)[12:3]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符已经不是标识符范围的了："\n"(10)[12:3]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 回溯字符："\n"(10)[12:3]
2019-06-21 08:00:36.277 [DEBUG] com.mytlx.compiler.lexer.Lexer - 已识别Token：< (12,2), FI, fi >
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 调用getToken方法
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："e"(101)[13:1]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入NORMAL状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："n"(110)[13:2]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："d"(100)[13:3]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："\n"(10)[13:4]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符已经不是标识符范围的了："\n"(10)[13:4]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 回溯字符："\n"(10)[13:4]
2019-06-21 08:00:36.277 [DEBUG] com.mytlx.compiler.lexer.Lexer - 已识别Token：< (13,3), END, end >
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 调用getToken方法
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："b"(98)[14:1]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入NORMAL状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："e"(101)[14:2]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："g"(103)[14:3]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："i"(105)[14:4]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："n"(110)[14:5]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："\n"(10)[14:6]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符已经不是标识符范围的了："\n"(10)[14:6]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 回溯字符："\n"(10)[14:6]
2019-06-21 08:00:36.277 [DEBUG] com.mytlx.compiler.lexer.Lexer - 已识别Token：< (14,5), BEGIN, begin >
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 调用getToken方法
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："r"(114)[15:1]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入NORMAL状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："e"(101)[15:2]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："a"(97)[15:3]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："d"(100)[15:4]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："("(40)[15:5]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符已经不是标识符范围的了："("(40)[15:5]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 回溯字符："("(40)[15:5]
2019-06-21 08:00:36.277 [DEBUG] com.mytlx.compiler.lexer.Lexer - 已识别Token：< (15,4), READ, read >
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 调用getToken方法
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："("(40)[15:5]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入NORMAL状态
2019-06-21 08:00:36.277 [DEBUG] com.mytlx.compiler.lexer.Lexer - 已识别Token：< (15,5), LPAREN, ( >
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 调用getToken方法
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："s"(115)[15:6]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入NORMAL状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是：")"(41)[15:7]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符已经不是标识符范围的了：")"(41)[15:7]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 回溯字符：")"(41)[15:7]
2019-06-21 08:00:36.277 [DEBUG] com.mytlx.compiler.lexer.Lexer - 已识别Token：< (15,6), ID, s >
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 调用getToken方法
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是：")"(41)[15:7]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入NORMAL状态
2019-06-21 08:00:36.277 [DEBUG] com.mytlx.compiler.lexer.Lexer - 已识别Token：< (15,7), RPAREN, ) >
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 调用getToken方法
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是：";"(59)[15:8]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入NORMAL状态
2019-06-21 08:00:36.277 [DEBUG] com.mytlx.compiler.lexer.Lexer - 已识别Token：< (15,8), SEMI, ; >
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 调用getToken方法
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："\n"(10)[15:9]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入NORMAL状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："f"(102)[16:1]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入NORMAL状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："a"(97)[16:2]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："c"(99)[16:3]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："t"(116)[16:4]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："o"(111)[16:5]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："r"(114)[16:6]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："("(40)[16:7]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符已经不是标识符范围的了："("(40)[16:7]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 回溯字符："("(40)[16:7]
2019-06-21 08:00:36.277 [DEBUG] com.mytlx.compiler.lexer.Lexer - 已识别Token：< (16,6), ID, factor >
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 调用getToken方法
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："("(40)[16:7]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入NORMAL状态
2019-06-21 08:00:36.277 [DEBUG] com.mytlx.compiler.lexer.Lexer - 已识别Token：< (16,7), LPAREN, ( >
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 调用getToken方法
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："s"(115)[16:8]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入NORMAL状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是：","(44)[16:9]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符已经不是标识符范围的了：","(44)[16:9]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 回溯字符：","(44)[16:9]
2019-06-21 08:00:36.277 [DEBUG] com.mytlx.compiler.lexer.Lexer - 已识别Token：< (16,8), ID, s >
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 调用getToken方法
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是：","(44)[16:9]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入NORMAL状态
2019-06-21 08:00:36.277 [DEBUG] com.mytlx.compiler.lexer.Lexer - 已识别Token：< (16,9), COMMA, , >
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 调用getToken方法
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："t"(116)[16:10]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入NORMAL状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是：")"(41)[16:11]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符已经不是标识符范围的了：")"(41)[16:11]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 回溯字符：")"(41)[16:11]
2019-06-21 08:00:36.277 [DEBUG] com.mytlx.compiler.lexer.Lexer - 已识别Token：< (16,10), ID, t >
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 调用getToken方法
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是：")"(41)[16:11]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入NORMAL状态
2019-06-21 08:00:36.277 [DEBUG] com.mytlx.compiler.lexer.Lexer - 已识别Token：< (16,11), RPAREN, ) >
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 调用getToken方法
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是：";"(59)[16:12]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入NORMAL状态
2019-06-21 08:00:36.277 [DEBUG] com.mytlx.compiler.lexer.Lexer - 已识别Token：< (16,12), SEMI, ; >
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 调用getToken方法
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："\n"(10)[16:13]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入NORMAL状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："w"(119)[17:1]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入NORMAL状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："r"(114)[17:2]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："i"(105)[17:3]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："t"(116)[17:4]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："e"(101)[17:5]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："("(40)[17:6]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符已经不是标识符范围的了："("(40)[17:6]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 回溯字符："("(40)[17:6]
2019-06-21 08:00:36.277 [DEBUG] com.mytlx.compiler.lexer.Lexer - 已识别Token：< (17,5), WRITE, write >
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 调用getToken方法
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："("(40)[17:6]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入NORMAL状态
2019-06-21 08:00:36.277 [DEBUG] com.mytlx.compiler.lexer.Lexer - 已识别Token：< (17,6), LPAREN, ( >
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 调用getToken方法
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："t"(116)[17:7]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入NORMAL状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是：")"(41)[17:8]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符已经不是标识符范围的了：")"(41)[17:8]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 回溯字符：")"(41)[17:8]
2019-06-21 08:00:36.277 [DEBUG] com.mytlx.compiler.lexer.Lexer - 已识别Token：< (17,7), ID, t >
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 调用getToken方法
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是：")"(41)[17:8]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入NORMAL状态
2019-06-21 08:00:36.277 [DEBUG] com.mytlx.compiler.lexer.Lexer - 已识别Token：< (17,8), RPAREN, ) >
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 调用getToken方法
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："\n"(10)[17:9]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入NORMAL状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："e"(101)[18:1]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入NORMAL状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："n"(110)[18:2]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："d"(100)[18:3]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："."(46)[18:4]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入ID状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符已经不是标识符范围的了："."(46)[18:4]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 回溯字符："."(46)[18:4]
2019-06-21 08:00:36.277 [DEBUG] com.mytlx.compiler.lexer.Lexer - 已识别Token：< (18,3), END, end >
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 调用getToken方法
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："."(46)[18:4]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入NORMAL状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是：" "(32)[18:5]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 进入DOT状态
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："\n"(10)[18:6]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："￿"(-1)[19:0]
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 结束标志
2019-06-21 08:00:36.277 [DEBUG] com.mytlx.compiler.lexer.Lexer - 已识别Token：< (18,4), EOF, . >
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 调用getToken方法
2019-06-21 08:00:36.277 [TRACE] com.mytlx.compiler.lexer.Lexer - 当前字符是："￿"(-1)[20:0]
2019-06-21 08:00:36.277 [INFO ] com.mytlx.compiler.syntax.LL1.LexParse - =========================词法分析结束============================
2019-06-21 08:00:36.277 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - =========================语法分析开始=============================
2019-06-21 08:00:36.324 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<Program>
2019-06-21 08:00:36.324 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (1,7), PROGRAM, program >
2019-06-21 08:00:36.324 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：Program ] [ 输入符号：program ]
2019-06-21 08:00:36.652 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<Program>
2019-06-21 08:00:36.668 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@37512735[node=ProgramHead ,value=ProgramHead], com.mytlx.compiler.syntax.symbol.NonTerminal@60b73889[node=DeclarePart ,value=DeclarePart], com.mytlx.compiler.syntax.symbol.NonTerminal@2066de14[node=ProgramBody ,value=ProgramBody], com.mytlx.compiler.syntax.symbol.Terminal@295abd3c[node=. ,token=< (0,0), EOF, . >]]
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建Program的子树：ProgramHead DeclarePart ProgramBody . 
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<ProgramHead>
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (1,7), PROGRAM, program >
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：ProgramHead ] [ 输入符号：program ]
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<ProgramHead>
2019-06-21 08:00:36.668 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.Terminal@67caa5bd[node=program ,token=< (0,0), PROGRAM, program >], com.mytlx.compiler.syntax.symbol.NonTerminal@260b330b[node=ProgramName ,value=ProgramName]]
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建ProgramHead的子树：program ProgramName 
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是终结符：<PROGRAM>
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 获取下一个Token：< (1,7), PROGRAM, program >
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 已匹配：< (1,7), PROGRAM, program >
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - ##########终结符识别完毕：<program> ###########
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<ProgramName>
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (1,10), ID, sd >
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：ProgramName ] [ 输入符号：sd ]
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<ProgramName>
2019-06-21 08:00:36.668 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.Terminal@56c48c01[node=id ,token=< (0,0), ID, id >]]
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建ProgramName的子树：id 
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是终结符：<ID>
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 获取下一个Token：< (1,10), ID, sd >
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 已匹配：< (1,10), ID, sd >
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - ##########终结符识别完毕：<sd> ###########
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<DeclarePart>
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (2,3), VAR, var >
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：DeclarePart ] [ 输入符号：var ]
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<DeclarePart>
2019-06-21 08:00:36.668 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@7101e92[node=TypeDecpart ,value=TypeDecpart], com.mytlx.compiler.syntax.symbol.NonTerminal@589d5a6f[node=VarDecpart ,value=VarDecpart], com.mytlx.compiler.syntax.symbol.NonTerminal@75097891[node=ProcDecpart ,value=ProcDecpart]]
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建DeclarePart的子树：TypeDecpart VarDecpart ProcDecpart 
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<TypeDecpart>
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (2,3), VAR, var >
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：TypeDecpart ] [ 输入符号：var ]
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<TypeDecpart>
2019-06-21 08:00:36.668 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@3002b31[node=blank ,value=blank]]
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建TypeDecpart的子树：blank 
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<VarDecpart>
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (2,3), VAR, var >
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：VarDecpart ] [ 输入符号：var ]
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<VarDecpart>
2019-06-21 08:00:36.668 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@1fdd82d9[node=VarDec ,value=VarDec]]
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建VarDecpart的子树：VarDec 
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<VarDec>
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (2,3), VAR, var >
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：VarDec ] [ 输入符号：var ]
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<VarDec>
2019-06-21 08:00:36.668 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.Terminal@4e23cdb5[node=var ,token=< (0,0), VAR, var >], com.mytlx.compiler.syntax.symbol.NonTerminal@64bd191d[node=VarDecList ,value=VarDecList]]
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建VarDec的子树：var VarDecList 
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是终结符：<VAR>
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 获取下一个Token：< (2,3), VAR, var >
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 已匹配：< (2,3), VAR, var >
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - ##########终结符识别完毕：<var> ###########
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<VarDecList>
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (2,11), INTEGER, integer >
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：VarDecList ] [ 输入符号：integer ]
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<VarDecList>
2019-06-21 08:00:36.668 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@5be09fc[node=TypeDef ,value=TypeDef], com.mytlx.compiler.syntax.symbol.NonTerminal@fc3182b[node=VarIdList ,value=VarIdList], com.mytlx.compiler.syntax.symbol.Terminal@573b3a35[node=; ,token=< (0,0), SEMI, ; >], com.mytlx.compiler.syntax.symbol.NonTerminal@4cf1a10e[node=VarDecMore ,value=VarDecMore]]
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建VarDecList的子树：TypeDef VarIdList ; VarDecMore 
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<TypeDef>
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (2,11), INTEGER, integer >
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：TypeDef ] [ 输入符号：integer ]
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<TypeDef>
2019-06-21 08:00:36.668 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@5926e398[node=BaseType ,value=BaseType]]
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建TypeDef的子树：BaseType 
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<BaseType>
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (2,11), INTEGER, integer >
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：BaseType ] [ 输入符号：integer ]
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<BaseType>
2019-06-21 08:00:36.668 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.Terminal@3e9658ac[node=integer ,token=< (0,0), INTEGER, integer >]]
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建BaseType的子树：integer 
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是终结符：<INTEGER>
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 获取下一个Token：< (2,11), INTEGER, integer >
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 已匹配：< (2,11), INTEGER, integer >
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - ##########终结符识别完毕：<integer> ###########
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<VarIdList>
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (2,13), ID, s >
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：VarIdList ] [ 输入符号：s ]
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<VarIdList>
2019-06-21 08:00:36.668 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.Terminal@30642a99[node=id ,token=< (0,0), ID, id >], com.mytlx.compiler.syntax.symbol.NonTerminal@723ebb3e[node=VarIdMore ,value=VarIdMore]]
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建VarIdList的子树：id VarIdMore 
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是终结符：<ID>
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 获取下一个Token：< (2,13), ID, s >
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 已匹配：< (2,13), ID, s >
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - ##########终结符识别完毕：<s> ###########
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<VarIdMore>
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (2,14), SEMI, ; >
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：VarIdMore ] [ 输入符号：; ]
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<VarIdMore>
2019-06-21 08:00:36.668 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@57a272f[node=blank ,value=blank]]
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建VarIdMore的子树：blank 
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是终结符：<SEMI>
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 获取下一个Token：< (2,14), SEMI, ; >
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 已匹配：< (2,14), SEMI, ; >
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - ##########终结符识别完毕：<;> ###########
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<VarDecMore>
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (3,11), INTEGER, integer >
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：VarDecMore ] [ 输入符号：integer ]
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<VarDecMore>
2019-06-21 08:00:36.668 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@4152f4c3[node=VarDecList ,value=VarDecList]]
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建VarDecMore的子树：VarDecList 
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<VarDecList>
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (3,11), INTEGER, integer >
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：VarDecList ] [ 输入符号：integer ]
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<VarDecList>
2019-06-21 08:00:36.668 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@d7a3bd1[node=TypeDef ,value=TypeDef], com.mytlx.compiler.syntax.symbol.NonTerminal@f3dd8c2[node=VarIdList ,value=VarIdList], com.mytlx.compiler.syntax.symbol.Terminal@637c8ce7[node=; ,token=< (0,0), SEMI, ; >], com.mytlx.compiler.syntax.symbol.NonTerminal@3efc9685[node=VarDecMore ,value=VarDecMore]]
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建VarDecList的子树：TypeDef VarIdList ; VarDecMore 
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<TypeDef>
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (3,11), INTEGER, integer >
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：TypeDef ] [ 输入符号：integer ]
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<TypeDef>
2019-06-21 08:00:36.668 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@2a3e664a[node=BaseType ,value=BaseType]]
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建TypeDef的子树：BaseType 
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<BaseType>
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (3,11), INTEGER, integer >
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：BaseType ] [ 输入符号：integer ]
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<BaseType>
2019-06-21 08:00:36.668 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.Terminal@5384fe01[node=integer ,token=< (0,0), INTEGER, integer >]]
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建BaseType的子树：integer 
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是终结符：<INTEGER>
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 获取下一个Token：< (3,11), INTEGER, integer >
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 已匹配：< (3,11), INTEGER, integer >
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - ##########终结符识别完毕：<integer> ###########
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<VarIdList>
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (3,13), ID, t >
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：VarIdList ] [ 输入符号：t ]
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<VarIdList>
2019-06-21 08:00:36.668 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.Terminal@b9e2409[node=id ,token=< (0,0), ID, id >], com.mytlx.compiler.syntax.symbol.NonTerminal@f83240d[node=VarIdMore ,value=VarIdMore]]
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建VarIdList的子树：id VarIdMore 
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是终结符：<ID>
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 获取下一个Token：< (3,13), ID, t >
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 已匹配：< (3,13), ID, t >
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - ##########终结符识别完毕：<t> ###########
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<VarIdMore>
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (3,14), SEMI, ; >
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：VarIdMore ] [ 输入符号：; ]
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<VarIdMore>
2019-06-21 08:00:36.668 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@7f6f0462[node=blank ,value=blank]]
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建VarIdMore的子树：blank 
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是终结符：<SEMI>
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 获取下一个Token：< (3,14), SEMI, ; >
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 已匹配：< (3,14), SEMI, ; >
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - ##########终结符识别完毕：<;> ###########
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<VarDecMore>
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (4,9), PROCEDURE, procedure >
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：VarDecMore ] [ 输入符号：procedure ]
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<VarDecMore>
2019-06-21 08:00:36.668 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@725c13b7[node=blank ,value=blank]]
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建VarDecMore的子树：blank 
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<ProcDecpart>
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (4,9), PROCEDURE, procedure >
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：ProcDecpart ] [ 输入符号：procedure ]
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<ProcDecpart>
2019-06-21 08:00:36.668 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@3fa68e38[node=ProcDec ,value=ProcDec]]
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建ProcDecpart的子树：ProcDec 
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<ProcDec>
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (4,9), PROCEDURE, procedure >
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：ProcDec ] [ 输入符号：procedure ]
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<ProcDec>
2019-06-21 08:00:36.668 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.Terminal@634a39f[node=procedure ,token=< (0,0), PROCEDURE, procedure >], com.mytlx.compiler.syntax.symbol.NonTerminal@71cc1962[node=ProcName ,value=ProcName], com.mytlx.compiler.syntax.symbol.Terminal@2a501401[node=( ,token=< (0,0), LPAREN, ( >], com.mytlx.compiler.syntax.symbol.NonTerminal@45f3fc92[node=ParamList ,value=ParamList], com.mytlx.compiler.syntax.symbol.Terminal@2a7ddbd3[node=) ,token=< (0,0), RPAREN, ) >], com.mytlx.compiler.syntax.symbol.Terminal@33d26962[node=; ,token=< (0,0), SEMI, ; >], com.mytlx.compiler.syntax.symbol.NonTerminal@465898cc[node=ProcDecPart ,value=ProcDecPart], com.mytlx.compiler.syntax.symbol.NonTerminal@3df36a97[node=ProcBody ,value=ProcBody], com.mytlx.compiler.syntax.symbol.NonTerminal@3910b6f4[node=ProcDecMore ,value=ProcDecMore]]
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建ProcDec的子树：procedure ProcName ( ParamList ) ; ProcDecPart ProcBody ProcDecMore 
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是终结符：<PROCEDURE>
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 获取下一个Token：< (4,9), PROCEDURE, procedure >
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 已匹配：< (4,9), PROCEDURE, procedure >
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - ##########终结符识别完毕：<procedure> ###########
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<ProcName>
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (4,16), ID, factor >
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：ProcName ] [ 输入符号：factor ]
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<ProcName>
2019-06-21 08:00:36.668 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.Terminal@729daf9c[node=id ,token=< (0,0), ID, id >]]
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建ProcName的子树：id 
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是终结符：<ID>
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 获取下一个Token：< (4,16), ID, factor >
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 已匹配：< (4,16), ID, factor >
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - ##########终结符识别完毕：<factor> ###########
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是终结符：<LPAREN>
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 获取下一个Token：< (4,17), LPAREN, ( >
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 已匹配：< (4,17), LPAREN, ( >
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - ##########终结符识别完毕：<(> ###########
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<ParamList>
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (4,24), INTEGER, integer >
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：ParamList ] [ 输入符号：integer ]
2019-06-21 08:00:36.668 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<ParamList>
2019-06-21 08:00:36.683 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@3eb85d71[node=ParamDecList ,value=ParamDecList]]
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建ParamList的子树：ParamDecList 
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<ParamDecList>
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (4,24), INTEGER, integer >
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：ParamDecList ] [ 输入符号：integer ]
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<ParamDecList>
2019-06-21 08:00:36.683 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@5f62261c[node=Param ,value=Param], com.mytlx.compiler.syntax.symbol.NonTerminal@35a17f58[node=ParamMore ,value=ParamMore]]
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建ParamDecList的子树：Param ParamMore 
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<Param>
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (4,24), INTEGER, integer >
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：Param ] [ 输入符号：integer ]
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<Param>
2019-06-21 08:00:36.683 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@68b5e3b2[node=TypeDef ,value=TypeDef], com.mytlx.compiler.syntax.symbol.NonTerminal@68e690c6[node=FormList ,value=FormList]]
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建Param的子树：TypeDef FormList 
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<TypeDef>
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (4,24), INTEGER, integer >
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：TypeDef ] [ 输入符号：integer ]
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<TypeDef>
2019-06-21 08:00:36.683 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@4250691a[node=BaseType ,value=BaseType]]
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建TypeDef的子树：BaseType 
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<BaseType>
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (4,24), INTEGER, integer >
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：BaseType ] [ 输入符号：integer ]
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<BaseType>
2019-06-21 08:00:36.683 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.Terminal@535522dc[node=integer ,token=< (0,0), INTEGER, integer >]]
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建BaseType的子树：integer 
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是终结符：<INTEGER>
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 获取下一个Token：< (4,24), INTEGER, integer >
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 已匹配：< (4,24), INTEGER, integer >
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - ##########终结符识别完毕：<integer> ###########
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<FormList>
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (4,26), ID, n >
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：FormList ] [ 输入符号：n ]
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<FormList>
2019-06-21 08:00:36.683 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.Terminal@2aebd71c[node=id ,token=< (0,0), ID, id >], com.mytlx.compiler.syntax.symbol.NonTerminal@5ca10402[node=FidMore ,value=FidMore]]
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建FormList的子树：id FidMore 
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是终结符：<ID>
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 获取下一个Token：< (4,26), ID, n >
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 已匹配：< (4,26), ID, n >
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - ##########终结符识别完毕：<n> ###########
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<FidMore>
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (4,27), SEMI, ; >
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：FidMore ] [ 输入符号：; ]
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<FidMore>
2019-06-21 08:00:36.683 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@6a8c8d59[node=blank ,value=blank]]
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建FidMore的子树：blank 
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<ParamMore>
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (4,27), SEMI, ; >
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：ParamMore ] [ 输入符号：; ]
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<ParamMore>
2019-06-21 08:00:36.683 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.Terminal@7c8b226c[node=; ,token=< (0,0), SEMI, ; >], com.mytlx.compiler.syntax.symbol.NonTerminal@34b3a049[node=ParamDecList ,value=ParamDecList]]
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建ParamMore的子树：; ParamDecList 
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是终结符：<SEMI>
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 获取下一个Token：< (4,27), SEMI, ; >
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 已匹配：< (4,27), SEMI, ; >
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - ##########终结符识别完毕：<;> ###########
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<ParamDecList>
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (4,30), VAR, var >
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：ParamDecList ] [ 输入符号：var ]
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<ParamDecList>
2019-06-21 08:00:36.683 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@295376fe[node=Param ,value=Param], com.mytlx.compiler.syntax.symbol.NonTerminal@734a39f3[node=ParamMore ,value=ParamMore]]
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建ParamDecList的子树：Param ParamMore 
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<Param>
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (4,30), VAR, var >
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：Param ] [ 输入符号：var ]
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<Param>
2019-06-21 08:00:36.683 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.Terminal@23174adf[node=var ,token=< (0,0), VAR, var >], com.mytlx.compiler.syntax.symbol.NonTerminal@507e1845[node=TypeDef ,value=TypeDef], com.mytlx.compiler.syntax.symbol.NonTerminal@4c74b82[node=FormList ,value=FormList]]
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建Param的子树：var TypeDef FormList 
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是终结符：<VAR>
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 获取下一个Token：< (4,30), VAR, var >
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 已匹配：< (4,30), VAR, var >
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - ##########终结符识别完毕：<var> ###########
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<TypeDef>
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (4,38), INTEGER, integer >
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：TypeDef ] [ 输入符号：integer ]
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<TypeDef>
2019-06-21 08:00:36.683 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@72ce68d5[node=BaseType ,value=BaseType]]
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建TypeDef的子树：BaseType 
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<BaseType>
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (4,38), INTEGER, integer >
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：BaseType ] [ 输入符号：integer ]
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<BaseType>
2019-06-21 08:00:36.683 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.Terminal@32ba5138[node=integer ,token=< (0,0), INTEGER, integer >]]
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建BaseType的子树：integer 
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是终结符：<INTEGER>
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 获取下一个Token：< (4,38), INTEGER, integer >
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 已匹配：< (4,38), INTEGER, integer >
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - ##########终结符识别完毕：<integer> ###########
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<FormList>
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (4,40), ID, m >
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：FormList ] [ 输入符号：m ]
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<FormList>
2019-06-21 08:00:36.683 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.Terminal@6bf18ed[node=id ,token=< (0,0), ID, id >], com.mytlx.compiler.syntax.symbol.NonTerminal@2d99a6e8[node=FidMore ,value=FidMore]]
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建FormList的子树：id FidMore 
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是终结符：<ID>
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 获取下一个Token：< (4,40), ID, m >
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 已匹配：< (4,40), ID, m >
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - ##########终结符识别完毕：<m> ###########
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<FidMore>
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (4,41), RPAREN, ) >
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：FidMore ] [ 输入符号：) ]
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<FidMore>
2019-06-21 08:00:36.683 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@5024ab14[node=blank ,value=blank]]
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建FidMore的子树：blank 
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<ParamMore>
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (4,41), RPAREN, ) >
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：ParamMore ] [ 输入符号：) ]
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<ParamMore>
2019-06-21 08:00:36.683 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@4700f503[node=blank ,value=blank]]
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建ParamMore的子树：blank 
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是终结符：<RPAREN>
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 获取下一个Token：< (4,41), RPAREN, ) >
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 已匹配：< (4,41), RPAREN, ) >
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - ##########终结符识别完毕：<)> ###########
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是终结符：<SEMI>
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 获取下一个Token：< (4,42), SEMI, ; >
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 已匹配：< (4,42), SEMI, ; >
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - ##########终结符识别完毕：<;> ###########
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<ProcDecPart>
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (5,3), VAR, var >
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：ProcDecPart ] [ 输入符号：var ]
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<ProcDecPart>
2019-06-21 08:00:36.683 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@1ce65d8c[node=DeclarePart ,value=DeclarePart]]
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建ProcDecPart的子树：DeclarePart 
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<DeclarePart>
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (5,3), VAR, var >
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：DeclarePart ] [ 输入符号：var ]
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<DeclarePart>
2019-06-21 08:00:36.683 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@e5d0a45[node=TypeDecpart ,value=TypeDecpart], com.mytlx.compiler.syntax.symbol.NonTerminal@303b3a85[node=VarDecpart ,value=VarDecpart], com.mytlx.compiler.syntax.symbol.NonTerminal@32b0233d[node=ProcDecpart ,value=ProcDecpart]]
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建DeclarePart的子树：TypeDecpart VarDecpart ProcDecpart 
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<TypeDecpart>
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (5,3), VAR, var >
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：TypeDecpart ] [ 输入符号：var ]
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<TypeDecpart>
2019-06-21 08:00:36.683 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@3d381c3a[node=blank ,value=blank]]
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建TypeDecpart的子树：blank 
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<VarDecpart>
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (5,3), VAR, var >
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：VarDecpart ] [ 输入符号：var ]
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<VarDecpart>
2019-06-21 08:00:36.683 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@12c11e9d[node=VarDec ,value=VarDec]]
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建VarDecpart的子树：VarDec 
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<VarDec>
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (5,3), VAR, var >
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：VarDec ] [ 输入符号：var ]
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<VarDec>
2019-06-21 08:00:36.683 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.Terminal@4ca1c382[node=var ,token=< (0,0), VAR, var >], com.mytlx.compiler.syntax.symbol.NonTerminal@33f59c24[node=VarDecList ,value=VarDecList]]
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建VarDec的子树：var VarDecList 
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是终结符：<VAR>
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 获取下一个Token：< (5,3), VAR, var >
2019-06-21 08:00:36.683 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 已匹配：< (5,3), VAR, var >
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - ##########终结符识别完毕：<var> ###########
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<VarDecList>
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (5,11), INTEGER, integer >
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：VarDecList ] [ 输入符号：integer ]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<VarDecList>
2019-06-21 08:00:36.699 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@5232aa5f[node=TypeDef ,value=TypeDef], com.mytlx.compiler.syntax.symbol.NonTerminal@a6795b7[node=VarIdList ,value=VarIdList], com.mytlx.compiler.syntax.symbol.Terminal@6bcc25dc[node=; ,token=< (0,0), SEMI, ; >], com.mytlx.compiler.syntax.symbol.NonTerminal@5dd9fd63[node=VarDecMore ,value=VarDecMore]]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建VarDecList的子树：TypeDef VarIdList ; VarDecMore 
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<TypeDef>
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (5,11), INTEGER, integer >
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：TypeDef ] [ 输入符号：integer ]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<TypeDef>
2019-06-21 08:00:36.699 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@c7a1cf8[node=BaseType ,value=BaseType]]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建TypeDef的子树：BaseType 
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<BaseType>
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (5,11), INTEGER, integer >
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：BaseType ] [ 输入符号：integer ]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<BaseType>
2019-06-21 08:00:36.699 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.Terminal@149f4e8a[node=integer ,token=< (0,0), INTEGER, integer >]]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建BaseType的子树：integer 
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是终结符：<INTEGER>
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 获取下一个Token：< (5,11), INTEGER, integer >
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 已匹配：< (5,11), INTEGER, integer >
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - ##########终结符识别完毕：<integer> ###########
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<VarIdList>
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (5,13), ID, w >
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：VarIdList ] [ 输入符号：w ]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<VarIdList>
2019-06-21 08:00:36.699 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.Terminal@6bb3d0a7[node=id ,token=< (0,0), ID, id >], com.mytlx.compiler.syntax.symbol.NonTerminal@53653d5b[node=VarIdMore ,value=VarIdMore]]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建VarIdList的子树：id VarIdMore 
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是终结符：<ID>
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 获取下一个Token：< (5,13), ID, w >
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 已匹配：< (5,13), ID, w >
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - ##########终结符识别完毕：<w> ###########
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<VarIdMore>
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (5,14), SEMI, ; >
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：VarIdMore ] [ 输入符号：; ]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<VarIdMore>
2019-06-21 08:00:36.699 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@12e609e9[node=blank ,value=blank]]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建VarIdMore的子树：blank 
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是终结符：<SEMI>
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 获取下一个Token：< (5,14), SEMI, ; >
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 已匹配：< (5,14), SEMI, ; >
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - ##########终结符识别完毕：<;> ###########
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<VarDecMore>
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (6,5), BEGIN, begin >
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：VarDecMore ] [ 输入符号：begin ]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<VarDecMore>
2019-06-21 08:00:36.699 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@10eeda2b[node=blank ,value=blank]]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建VarDecMore的子树：blank 
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<ProcDecpart>
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (6,5), BEGIN, begin >
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：ProcDecpart ] [ 输入符号：begin ]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<ProcDecpart>
2019-06-21 08:00:36.699 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@231974fd[node=blank ,value=blank]]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建ProcDecpart的子树：blank 
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<ProcBody>
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (6,5), BEGIN, begin >
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：ProcBody ] [ 输入符号：begin ]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<ProcBody>
2019-06-21 08:00:36.699 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@72022767[node=ProgramBody ,value=ProgramBody]]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建ProcBody的子树：ProgramBody 
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<ProgramBody>
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (6,5), BEGIN, begin >
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：ProgramBody ] [ 输入符号：begin ]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<ProgramBody>
2019-06-21 08:00:36.699 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.Terminal@fb0c279[node=begin ,token=< (0,0), BEGIN, begin >], com.mytlx.compiler.syntax.symbol.NonTerminal@74ea1d41[node=StmList ,value=StmList], com.mytlx.compiler.syntax.symbol.Terminal@313e3d57[node=end ,token=< (0,0), END, end >]]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建ProgramBody的子树：begin StmList end 
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是终结符：<BEGIN>
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 获取下一个Token：< (6,5), BEGIN, begin >
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 已匹配：< (6,5), BEGIN, begin >
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - ##########终结符识别完毕：<begin> ###########
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<StmList>
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (7,2), IF, if >
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：StmList ] [ 输入符号：if ]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<StmList>
2019-06-21 08:00:36.699 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@1395d507[node=Stm ,value=Stm], com.mytlx.compiler.syntax.symbol.NonTerminal@786b0e3e[node=StmMore ,value=StmMore]]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建StmList的子树：Stm StmMore 
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<Stm>
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (7,2), IF, if >
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：Stm ] [ 输入符号：if ]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<Stm>
2019-06-21 08:00:36.699 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@6a446c83[node=ConditionalStm ,value=ConditionalStm]]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建Stm的子树：ConditionalStm 
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<ConditionalStm>
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (7,2), IF, if >
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：ConditionalStm ] [ 输入符号：if ]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<ConditionalStm>
2019-06-21 08:00:36.699 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.Terminal@159509b7[node=if ,token=< (0,0), IF, if >], com.mytlx.compiler.syntax.symbol.NonTerminal@644592d9[node=RelExp ,value=RelExp], com.mytlx.compiler.syntax.symbol.Terminal@44743cc[node=then ,token=< (0,0), THEN, then >], com.mytlx.compiler.syntax.symbol.NonTerminal@4c55e006[node=StmList ,value=StmList], com.mytlx.compiler.syntax.symbol.Terminal@7d1b7e6e[node=else ,token=< (0,0), ELSE, else >], com.mytlx.compiler.syntax.symbol.NonTerminal@6352260e[node=StmList ,value=StmList], com.mytlx.compiler.syntax.symbol.Terminal@7b6328dc[node=fi ,token=< (0,0), FI, fi >]]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建ConditionalStm的子树：if RelExp then StmList else StmList fi 
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是终结符：<IF>
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 获取下一个Token：< (7,2), IF, if >
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 已匹配：< (7,2), IF, if >
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - ##########终结符识别完毕：<if> ###########
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<RelExp>
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (7,4), ID, n >
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：RelExp ] [ 输入符号：n ]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<RelExp>
2019-06-21 08:00:36.699 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@43fa9e3b[node=Exp ,value=Exp], com.mytlx.compiler.syntax.symbol.NonTerminal@1e9100d2[node=OtherRelE ,value=OtherRelE]]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建RelExp的子树：Exp OtherRelE 
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<Exp>
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (7,4), ID, n >
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：Exp ] [ 输入符号：n ]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<Exp>
2019-06-21 08:00:36.699 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@45724d4d[node=Term ,value=Term], com.mytlx.compiler.syntax.symbol.NonTerminal@195e4fe1[node=OtherTerm ,value=OtherTerm]]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建Exp的子树：Term OtherTerm 
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<Term>
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (7,4), ID, n >
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：Term ] [ 输入符号：n ]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<Term>
2019-06-21 08:00:36.699 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@6c0e2945[node=Factor ,value=Factor], com.mytlx.compiler.syntax.symbol.NonTerminal@7224cd8e[node=OtherFactor ,value=OtherFactor]]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建Term的子树：Factor OtherFactor 
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<Factor>
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (7,4), ID, n >
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：Factor ] [ 输入符号：n ]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<Factor>
2019-06-21 08:00:36.699 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@5c956ec9[node=Variable ,value=Variable]]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建Factor的子树：Variable 
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<Variable>
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (7,4), ID, n >
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：Variable ] [ 输入符号：n ]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<Variable>
2019-06-21 08:00:36.699 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.Terminal@64cb38f7[node=id ,token=< (0,0), ID, id >], com.mytlx.compiler.syntax.symbol.NonTerminal@3d290fb1[node=VariMore ,value=VariMore]]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建Variable的子树：id VariMore 
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是终结符：<ID>
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 获取下一个Token：< (7,4), ID, n >
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 已匹配：< (7,4), ID, n >
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - ##########终结符识别完毕：<n> ###########
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<VariMore>
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (7,5), EQ, = >
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：VariMore ] [ 输入符号：= ]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<VariMore>
2019-06-21 08:00:36.699 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@17872297[node=blank ,value=blank]]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建VariMore的子树：blank 
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<OtherFactor>
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (7,5), EQ, = >
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：OtherFactor ] [ 输入符号：= ]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<OtherFactor>
2019-06-21 08:00:36.699 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@2417bd65[node=blank ,value=blank]]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建OtherFactor的子树：blank 
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<OtherTerm>
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (7,5), EQ, = >
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：OtherTerm ] [ 输入符号：= ]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<OtherTerm>
2019-06-21 08:00:36.699 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@4ed50b08[node=blank ,value=blank]]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建OtherTerm的子树：blank 
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<OtherRelE>
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (7,5), EQ, = >
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：OtherRelE ] [ 输入符号：= ]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<OtherRelE>
2019-06-21 08:00:36.699 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@3547a71f[node=CmpOp ,value=CmpOp], com.mytlx.compiler.syntax.symbol.NonTerminal@7394b38d[node=Exp ,value=Exp]]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建OtherRelE的子树：CmpOp Exp 
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<CmpOp>
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (7,5), EQ, = >
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：CmpOp ] [ 输入符号：= ]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<CmpOp>
2019-06-21 08:00:36.699 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.Terminal@41a0fe6d[node== ,token=< (0,0), EQ, = >]]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建CmpOp的子树：= 
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是终结符：<EQ>
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 获取下一个Token：< (7,5), EQ, = >
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 已匹配：< (7,5), EQ, = >
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - ##########终结符识别完毕：<=> ###########
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<Exp>
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (7,6), INTC, 0 >
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：Exp ] [ 输入符号：0 ]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<Exp>
2019-06-21 08:00:36.699 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@e4c9422[node=Term ,value=Term], com.mytlx.compiler.syntax.symbol.NonTerminal@3144d839[node=OtherTerm ,value=OtherTerm]]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建Exp的子树：Term OtherTerm 
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<Term>
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (7,6), INTC, 0 >
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：Term ] [ 输入符号：0 ]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<Term>
2019-06-21 08:00:36.699 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@295ae4e[node=Factor ,value=Factor], com.mytlx.compiler.syntax.symbol.NonTerminal@175cb2ec[node=OtherFactor ,value=OtherFactor]]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建Term的子树：Factor OtherFactor 
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<Factor>
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (7,6), INTC, 0 >
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：Factor ] [ 输入符号：0 ]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<Factor>
2019-06-21 08:00:36.699 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.Terminal@462fcbcb[node=intc ,token=< (0,0), INTC, intc >]]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建Factor的子树：intc 
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是终结符：<INTC>
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 获取下一个Token：< (7,6), INTC, 0 >
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 已匹配：< (7,6), INTC, 0 >
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - ##########终结符识别完毕：<0> ###########
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<OtherFactor>
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (8,4), THEN, then >
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：OtherFactor ] [ 输入符号：then ]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<OtherFactor>
2019-06-21 08:00:36.699 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@135d28dc[node=blank ,value=blank]]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建OtherFactor的子树：blank 
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<OtherTerm>
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (8,4), THEN, then >
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：OtherTerm ] [ 输入符号：then ]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<OtherTerm>
2019-06-21 08:00:36.699 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@6fde8fc4[node=blank ,value=blank]]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建OtherTerm的子树：blank 
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是终结符：<THEN>
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 获取下一个Token：< (8,4), THEN, then >
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 已匹配：< (8,4), THEN, then >
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - ##########终结符识别完毕：<then> ###########
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<StmList>
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (8,6), ID, m >
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：StmList ] [ 输入符号：m ]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<StmList>
2019-06-21 08:00:36.699 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@6b0811d3[node=Stm ,value=Stm], com.mytlx.compiler.syntax.symbol.NonTerminal@7dedfc4c[node=StmMore ,value=StmMore]]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建StmList的子树：Stm StmMore 
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<Stm>
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (8,6), ID, m >
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：Stm ] [ 输入符号：m ]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<Stm>
2019-06-21 08:00:36.699 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.Terminal@9f1869a[node=id ,token=< (0,0), ID, id >], com.mytlx.compiler.syntax.symbol.NonTerminal@ce2cd03[node=AssCall ,value=AssCall]]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建Stm的子树：id AssCall 
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是终结符：<ID>
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 获取下一个Token：< (8,6), ID, m >
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 已匹配：< (8,6), ID, m >
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - ##########终结符识别完毕：<m> ###########
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<AssCall>
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (8,8), ASSIGN, := >
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：AssCall ] [ 输入符号：:= ]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<AssCall>
2019-06-21 08:00:36.699 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@1c74c4e0[node=AssignmentRest ,value=AssignmentRest]]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建AssCall的子树：AssignmentRest 
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<AssignmentRest>
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (8,8), ASSIGN, := >
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：AssignmentRest ] [ 输入符号：:= ]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<AssignmentRest>
2019-06-21 08:00:36.699 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@6d97470e[node=VariMore ,value=VariMore], com.mytlx.compiler.syntax.symbol.Terminal@4cbdccc6[node=:= ,token=< (0,0), ASSIGN, := >], com.mytlx.compiler.syntax.symbol.NonTerminal@15df54[node=Exp ,value=Exp]]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建AssignmentRest的子树：VariMore := Exp 
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<VariMore>
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (8,8), ASSIGN, := >
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：VariMore ] [ 输入符号：:= ]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<VariMore>
2019-06-21 08:00:36.699 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@4a358c3[node=blank ,value=blank]]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建VariMore的子树：blank 
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是终结符：<ASSIGN>
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 获取下一个Token：< (8,8), ASSIGN, := >
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 已匹配：< (8,8), ASSIGN, := >
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - ##########终结符识别完毕：<:=> ###########
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<Exp>
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (8,9), INTC, 1 >
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：Exp ] [ 输入符号：1 ]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<Exp>
2019-06-21 08:00:36.699 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@1f0440e7[node=Term ,value=Term], com.mytlx.compiler.syntax.symbol.NonTerminal@44155a2d[node=OtherTerm ,value=OtherTerm]]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建Exp的子树：Term OtherTerm 
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<Term>
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (8,9), INTC, 1 >
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：Term ] [ 输入符号：1 ]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<Term>
2019-06-21 08:00:36.699 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@66c6a6cd[node=Factor ,value=Factor], com.mytlx.compiler.syntax.symbol.NonTerminal@210cf061[node=OtherFactor ,value=OtherFactor]]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建Term的子树：Factor OtherFactor 
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<Factor>
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (8,9), INTC, 1 >
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：Factor ] [ 输入符号：1 ]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<Factor>
2019-06-21 08:00:36.699 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.Terminal@6ffbaadb[node=intc ,token=< (0,0), INTC, intc >]]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建Factor的子树：intc 
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是终结符：<INTC>
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 获取下一个Token：< (8,9), INTC, 1 >
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 已匹配：< (8,9), INTC, 1 >
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - ##########终结符识别完毕：<1> ###########
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<OtherFactor>
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (9,4), ELSE, else >
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：OtherFactor ] [ 输入符号：else ]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<OtherFactor>
2019-06-21 08:00:36.699 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@2ead0479[node=blank ,value=blank]]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建OtherFactor的子树：blank 
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<OtherTerm>
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (9,4), ELSE, else >
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：OtherTerm ] [ 输入符号：else ]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<OtherTerm>
2019-06-21 08:00:36.699 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@7d1eaad8[node=blank ,value=blank]]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建OtherTerm的子树：blank 
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<StmMore>
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (9,4), ELSE, else >
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：StmMore ] [ 输入符号：else ]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<StmMore>
2019-06-21 08:00:36.699 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@57129259[node=blank ,value=blank]]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建StmMore的子树：blank 
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是终结符：<ELSE>
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 获取下一个Token：< (9,4), ELSE, else >
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 已匹配：< (9,4), ELSE, else >
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - ##########终结符识别完毕：<else> ###########
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<StmList>
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (10,8), ID, factor >
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：StmList ] [ 输入符号：factor ]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<StmList>
2019-06-21 08:00:36.699 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@559a9551[node=Stm ,value=Stm], com.mytlx.compiler.syntax.symbol.NonTerminal@51d2f10e[node=StmMore ,value=StmMore]]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建StmList的子树：Stm StmMore 
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<Stm>
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (10,8), ID, factor >
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：Stm ] [ 输入符号：factor ]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<Stm>
2019-06-21 08:00:36.699 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.Terminal@58d389f0[node=id ,token=< (0,0), ID, id >], com.mytlx.compiler.syntax.symbol.NonTerminal@49ddfa87[node=AssCall ,value=AssCall]]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建Stm的子树：id AssCall 
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是终结符：<ID>
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 获取下一个Token：< (10,8), ID, factor >
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 已匹配：< (10,8), ID, factor >
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - ##########终结符识别完毕：<factor> ###########
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<AssCall>
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (10,9), LPAREN, ( >
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：AssCall ] [ 输入符号：( ]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<AssCall>
2019-06-21 08:00:36.699 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@568a9b29[node=CallStmRest ,value=CallStmRest]]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建AssCall的子树：CallStmRest 
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<CallStmRest>
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (10,9), LPAREN, ( >
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：CallStmRest ] [ 输入符号：( ]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<CallStmRest>
2019-06-21 08:00:36.699 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.Terminal@b098b83[node=( ,token=< (0,0), LPAREN, ( >], com.mytlx.compiler.syntax.symbol.NonTerminal@30dbbbfe[node=ActParamList ,value=ActParamList], com.mytlx.compiler.syntax.symbol.Terminal@19a049de[node=) ,token=< (0,0), RPAREN, ) >]]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建CallStmRest的子树：( ActParamList ) 
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是终结符：<LPAREN>
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 获取下一个Token：< (10,9), LPAREN, ( >
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 已匹配：< (10,9), LPAREN, ( >
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - ##########终结符识别完毕：<(> ###########
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<ActParamList>
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (10,10), ID, n >
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：ActParamList ] [ 输入符号：n ]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<ActParamList>
2019-06-21 08:00:36.699 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@287f4712[node=Exp ,value=Exp], com.mytlx.compiler.syntax.symbol.NonTerminal@282c9e87[node=ActParamMore ,value=ActParamMore]]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建ActParamList的子树：Exp ActParamMore 
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<Exp>
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (10,10), ID, n >
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：Exp ] [ 输入符号：n ]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<Exp>
2019-06-21 08:00:36.699 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@46553981[node=Term ,value=Term], com.mytlx.compiler.syntax.symbol.NonTerminal@6903af77[node=OtherTerm ,value=OtherTerm]]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建Exp的子树：Term OtherTerm 
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<Term>
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (10,10), ID, n >
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：Term ] [ 输入符号：n ]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<Term>
2019-06-21 08:00:36.699 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@17fa5071[node=Factor ,value=Factor], com.mytlx.compiler.syntax.symbol.NonTerminal@7855e1f4[node=OtherFactor ,value=OtherFactor]]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建Term的子树：Factor OtherFactor 
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<Factor>
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (10,10), ID, n >
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：Factor ] [ 输入符号：n ]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<Factor>
2019-06-21 08:00:36.699 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@2244061f[node=Variable ,value=Variable]]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建Factor的子树：Variable 
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<Variable>
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (10,10), ID, n >
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：Variable ] [ 输入符号：n ]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<Variable>
2019-06-21 08:00:36.699 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.Terminal@3528535e[node=id ,token=< (0,0), ID, id >], com.mytlx.compiler.syntax.symbol.NonTerminal@5d1622fd[node=VariMore ,value=VariMore]]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建Variable的子树：id VariMore 
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是终结符：<ID>
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 获取下一个Token：< (10,10), ID, n >
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 已匹配：< (10,10), ID, n >
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - ##########终结符识别完毕：<n> ###########
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<VariMore>
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (10,11), MINUS, - >
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：VariMore ] [ 输入符号：- ]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<VariMore>
2019-06-21 08:00:36.699 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@790ebf25[node=blank ,value=blank]]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建VariMore的子树：blank 
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<OtherFactor>
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (10,11), MINUS, - >
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：OtherFactor ] [ 输入符号：- ]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<OtherFactor>
2019-06-21 08:00:36.699 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@703e6458[node=blank ,value=blank]]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建OtherFactor的子树：blank 
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<OtherTerm>
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (10,11), MINUS, - >
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：OtherTerm ] [ 输入符号：- ]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<OtherTerm>
2019-06-21 08:00:36.699 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@4fe0ac04[node=AddOp ,value=AddOp], com.mytlx.compiler.syntax.symbol.NonTerminal@4d4a34bf[node=Exp ,value=Exp]]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建OtherTerm的子树：AddOp Exp 
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<AddOp>
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (10,11), MINUS, - >
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：AddOp ] [ 输入符号：- ]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<AddOp>
2019-06-21 08:00:36.699 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.Terminal@1aa0faaa[node=- ,token=< (0,0), MINUS, - >]]
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建AddOp的子树：- 
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是终结符：<MINUS>
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 获取下一个Token：< (10,11), MINUS, - >
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 已匹配：< (10,11), MINUS, - >
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - ##########终结符识别完毕：<-> ###########
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<Exp>
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (10,12), INTC, 1 >
2019-06-21 08:00:36.699 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：Exp ] [ 输入符号：1 ]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<Exp>
2019-06-21 08:00:36.714 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@634462fc[node=Term ,value=Term], com.mytlx.compiler.syntax.symbol.NonTerminal@5c587576[node=OtherTerm ,value=OtherTerm]]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建Exp的子树：Term OtherTerm 
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<Term>
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (10,12), INTC, 1 >
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：Term ] [ 输入符号：1 ]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<Term>
2019-06-21 08:00:36.714 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@3b2af73b[node=Factor ,value=Factor], com.mytlx.compiler.syntax.symbol.NonTerminal@3f7df36a[node=OtherFactor ,value=OtherFactor]]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建Term的子树：Factor OtherFactor 
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<Factor>
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (10,12), INTC, 1 >
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：Factor ] [ 输入符号：1 ]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<Factor>
2019-06-21 08:00:36.714 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.Terminal@614010bd[node=intc ,token=< (0,0), INTC, intc >]]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建Factor的子树：intc 
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是终结符：<INTC>
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 获取下一个Token：< (10,12), INTC, 1 >
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 已匹配：< (10,12), INTC, 1 >
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - ##########终结符识别完毕：<1> ###########
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<OtherFactor>
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (10,13), COMMA, , >
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：OtherFactor ] [ 输入符号：, ]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<OtherFactor>
2019-06-21 08:00:36.714 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@6fe05fcb[node=blank ,value=blank]]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建OtherFactor的子树：blank 
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<OtherTerm>
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (10,13), COMMA, , >
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：OtherTerm ] [ 输入符号：, ]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<OtherTerm>
2019-06-21 08:00:36.714 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@49a4eb5f[node=blank ,value=blank]]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建OtherTerm的子树：blank 
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<ActParamMore>
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (10,13), COMMA, , >
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：ActParamMore ] [ 输入符号：, ]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<ActParamMore>
2019-06-21 08:00:36.714 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.Terminal@182c09f[node=, ,token=< (0,0), COMMA, , >], com.mytlx.compiler.syntax.symbol.NonTerminal@20b50bcd[node=ActParamList ,value=ActParamList]]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建ActParamMore的子树：, ActParamList 
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是终结符：<COMMA>
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 获取下一个Token：< (10,13), COMMA, , >
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 已匹配：< (10,13), COMMA, , >
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - ##########终结符识别完毕：<,> ###########
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<ActParamList>
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (10,14), ID, w >
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：ActParamList ] [ 输入符号：w ]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<ActParamList>
2019-06-21 08:00:36.714 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@1b1936aa[node=Exp ,value=Exp], com.mytlx.compiler.syntax.symbol.NonTerminal@56f8f950[node=ActParamMore ,value=ActParamMore]]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建ActParamList的子树：Exp ActParamMore 
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<Exp>
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (10,14), ID, w >
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：Exp ] [ 输入符号：w ]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<Exp>
2019-06-21 08:00:36.714 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@163b4ff6[node=Term ,value=Term], com.mytlx.compiler.syntax.symbol.NonTerminal@2d74cd9[node=OtherTerm ,value=OtherTerm]]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建Exp的子树：Term OtherTerm 
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<Term>
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (10,14), ID, w >
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：Term ] [ 输入符号：w ]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<Term>
2019-06-21 08:00:36.714 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@261f4f67[node=Factor ,value=Factor], com.mytlx.compiler.syntax.symbol.NonTerminal@2dfd413c[node=OtherFactor ,value=OtherFactor]]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建Term的子树：Factor OtherFactor 
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<Factor>
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (10,14), ID, w >
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：Factor ] [ 输入符号：w ]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<Factor>
2019-06-21 08:00:36.714 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@24ce8fa8[node=Variable ,value=Variable]]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建Factor的子树：Variable 
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<Variable>
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (10,14), ID, w >
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：Variable ] [ 输入符号：w ]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<Variable>
2019-06-21 08:00:36.714 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.Terminal@558900ba[node=id ,token=< (0,0), ID, id >], com.mytlx.compiler.syntax.symbol.NonTerminal@90c72d2[node=VariMore ,value=VariMore]]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建Variable的子树：id VariMore 
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是终结符：<ID>
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 获取下一个Token：< (10,14), ID, w >
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 已匹配：< (10,14), ID, w >
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - ##########终结符识别完毕：<w> ###########
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<VariMore>
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (10,15), RPAREN, ) >
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：VariMore ] [ 输入符号：) ]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<VariMore>
2019-06-21 08:00:36.714 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@7f4cb5a6[node=blank ,value=blank]]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建VariMore的子树：blank 
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<OtherFactor>
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (10,15), RPAREN, ) >
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：OtherFactor ] [ 输入符号：) ]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<OtherFactor>
2019-06-21 08:00:36.714 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@35bf3797[node=blank ,value=blank]]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建OtherFactor的子树：blank 
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<OtherTerm>
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (10,15), RPAREN, ) >
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：OtherTerm ] [ 输入符号：) ]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<OtherTerm>
2019-06-21 08:00:36.714 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@52d85a79[node=blank ,value=blank]]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建OtherTerm的子树：blank 
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<ActParamMore>
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (10,15), RPAREN, ) >
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：ActParamMore ] [ 输入符号：) ]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<ActParamMore>
2019-06-21 08:00:36.714 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@3b5f8b32[node=blank ,value=blank]]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建ActParamMore的子树：blank 
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是终结符：<RPAREN>
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 获取下一个Token：< (10,15), RPAREN, ) >
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 已匹配：< (10,15), RPAREN, ) >
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - ##########终结符识别完毕：<)> ###########
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<StmMore>
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (10,16), SEMI, ; >
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：StmMore ] [ 输入符号：; ]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<StmMore>
2019-06-21 08:00:36.714 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.Terminal@7a0c46f9[node=; ,token=< (0,0), SEMI, ; >], com.mytlx.compiler.syntax.symbol.NonTerminal@1eb58cfa[node=StmList ,value=StmList]]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建StmMore的子树：; StmList 
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是终结符：<SEMI>
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 获取下一个Token：< (10,16), SEMI, ; >
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 已匹配：< (10,16), SEMI, ; >
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - ##########终结符识别完毕：<;> ###########
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<StmList>
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (11,3), ID, m >
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：StmList ] [ 输入符号：m ]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<StmList>
2019-06-21 08:00:36.714 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@25e1e826[node=Stm ,value=Stm], com.mytlx.compiler.syntax.symbol.NonTerminal@7b9c78d5[node=StmMore ,value=StmMore]]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建StmList的子树：Stm StmMore 
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<Stm>
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (11,3), ID, m >
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：Stm ] [ 输入符号：m ]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<Stm>
2019-06-21 08:00:36.714 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.Terminal@6665a07c[node=id ,token=< (0,0), ID, id >], com.mytlx.compiler.syntax.symbol.NonTerminal@625a7258[node=AssCall ,value=AssCall]]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建Stm的子树：id AssCall 
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是终结符：<ID>
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 获取下一个Token：< (11,3), ID, m >
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 已匹配：< (11,3), ID, m >
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - ##########终结符识别完毕：<m> ###########
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<AssCall>
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (11,5), ASSIGN, := >
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：AssCall ] [ 输入符号：:= ]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<AssCall>
2019-06-21 08:00:36.714 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@834125f[node=AssignmentRest ,value=AssignmentRest]]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建AssCall的子树：AssignmentRest 
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<AssignmentRest>
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (11,5), ASSIGN, := >
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：AssignmentRest ] [ 输入符号：:= ]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<AssignmentRest>
2019-06-21 08:00:36.714 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@14588ba6[node=VariMore ,value=VariMore], com.mytlx.compiler.syntax.symbol.Terminal@2f73c368[node=:= ,token=< (0,0), ASSIGN, := >], com.mytlx.compiler.syntax.symbol.NonTerminal@3e6d5261[node=Exp ,value=Exp]]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建AssignmentRest的子树：VariMore := Exp 
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<VariMore>
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (11,5), ASSIGN, := >
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：VariMore ] [ 输入符号：:= ]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<VariMore>
2019-06-21 08:00:36.714 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@3533375f[node=blank ,value=blank]]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建VariMore的子树：blank 
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是终结符：<ASSIGN>
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 获取下一个Token：< (11,5), ASSIGN, := >
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 已匹配：< (11,5), ASSIGN, := >
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - ##########终结符识别完毕：<:=> ###########
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<Exp>
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (11,6), ID, n >
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：Exp ] [ 输入符号：n ]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<Exp>
2019-06-21 08:00:36.714 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@26c3a5c0[node=Term ,value=Term], com.mytlx.compiler.syntax.symbol.NonTerminal@200a36cc[node=OtherTerm ,value=OtherTerm]]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建Exp的子树：Term OtherTerm 
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<Term>
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (11,6), ID, n >
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：Term ] [ 输入符号：n ]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<Term>
2019-06-21 08:00:36.714 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@21725275[node=Factor ,value=Factor], com.mytlx.compiler.syntax.symbol.NonTerminal@27e9aef5[node=OtherFactor ,value=OtherFactor]]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建Term的子树：Factor OtherFactor 
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<Factor>
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (11,6), ID, n >
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：Factor ] [ 输入符号：n ]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<Factor>
2019-06-21 08:00:36.714 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@2e6f655d[node=Variable ,value=Variable]]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建Factor的子树：Variable 
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<Variable>
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (11,6), ID, n >
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：Variable ] [ 输入符号：n ]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<Variable>
2019-06-21 08:00:36.714 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.Terminal@303e3487[node=id ,token=< (0,0), ID, id >], com.mytlx.compiler.syntax.symbol.NonTerminal@1cf25fa0[node=VariMore ,value=VariMore]]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建Variable的子树：id VariMore 
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是终结符：<ID>
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 获取下一个Token：< (11,6), ID, n >
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 已匹配：< (11,6), ID, n >
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - ##########终结符识别完毕：<n> ###########
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<VariMore>
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (11,7), TIMES, * >
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：VariMore ] [ 输入符号：* ]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<VariMore>
2019-06-21 08:00:36.714 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@6a8d7301[node=blank ,value=blank]]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建VariMore的子树：blank 
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<OtherFactor>
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (11,7), TIMES, * >
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：OtherFactor ] [ 输入符号：* ]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<OtherFactor>
2019-06-21 08:00:36.714 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@6bc5b8[node=MultOp ,value=MultOp], com.mytlx.compiler.syntax.symbol.NonTerminal@12902778[node=Term ,value=Term]]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建OtherFactor的子树：MultOp Term 
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<MultOp>
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (11,7), TIMES, * >
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：MultOp ] [ 输入符号：* ]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<MultOp>
2019-06-21 08:00:36.714 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.Terminal@161c6559[node=* ,token=< (0,0), TIMES, * >]]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建MultOp的子树：* 
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是终结符：<TIMES>
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 获取下一个Token：< (11,7), TIMES, * >
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 已匹配：< (11,7), TIMES, * >
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - ##########终结符识别完毕：<*> ###########
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<Term>
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (11,8), ID, w >
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：Term ] [ 输入符号：w ]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<Term>
2019-06-21 08:00:36.714 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@5d58c920[node=Factor ,value=Factor], com.mytlx.compiler.syntax.symbol.NonTerminal@1c4058b4[node=OtherFactor ,value=OtherFactor]]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建Term的子树：Factor OtherFactor 
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<Factor>
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (11,8), ID, w >
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：Factor ] [ 输入符号：w ]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<Factor>
2019-06-21 08:00:36.714 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@62bba38a[node=Variable ,value=Variable]]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建Factor的子树：Variable 
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<Variable>
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (11,8), ID, w >
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：Variable ] [ 输入符号：w ]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<Variable>
2019-06-21 08:00:36.714 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.Terminal@e82a14c[node=id ,token=< (0,0), ID, id >], com.mytlx.compiler.syntax.symbol.NonTerminal@1d4c93da[node=VariMore ,value=VariMore]]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建Variable的子树：id VariMore 
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是终结符：<ID>
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 获取下一个Token：< (11,8), ID, w >
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 已匹配：< (11,8), ID, w >
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - ##########终结符识别完毕：<w> ###########
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<VariMore>
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (12,2), FI, fi >
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：VariMore ] [ 输入符号：fi ]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<VariMore>
2019-06-21 08:00:36.714 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@65a715f7[node=blank ,value=blank]]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建VariMore的子树：blank 
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<OtherFactor>
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (12,2), FI, fi >
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：OtherFactor ] [ 输入符号：fi ]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<OtherFactor>
2019-06-21 08:00:36.714 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@2ce7f62[node=blank ,value=blank]]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建OtherFactor的子树：blank 
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<OtherTerm>
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (12,2), FI, fi >
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：OtherTerm ] [ 输入符号：fi ]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<OtherTerm>
2019-06-21 08:00:36.714 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@27736cf2[node=blank ,value=blank]]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建OtherTerm的子树：blank 
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<StmMore>
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (12,2), FI, fi >
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：StmMore ] [ 输入符号：fi ]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<StmMore>
2019-06-21 08:00:36.714 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@20a0cb6[node=blank ,value=blank]]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建StmMore的子树：blank 
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是终结符：<FI>
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 获取下一个Token：< (12,2), FI, fi >
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 已匹配：< (12,2), FI, fi >
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - ##########终结符识别完毕：<fi> ###########
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<StmMore>
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (13,3), END, end >
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：StmMore ] [ 输入符号：end ]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<StmMore>
2019-06-21 08:00:36.714 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@72ff5a79[node=blank ,value=blank]]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建StmMore的子树：blank 
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是终结符：<END>
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 获取下一个Token：< (13,3), END, end >
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 已匹配：< (13,3), END, end >
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - ##########终结符识别完毕：<end> ###########
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<ProcDecMore>
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (14,5), BEGIN, begin >
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：ProcDecMore ] [ 输入符号：begin ]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<ProcDecMore>
2019-06-21 08:00:36.714 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@214bc958[node=blank ,value=blank]]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建ProcDecMore的子树：blank 
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<ProgramBody>
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (14,5), BEGIN, begin >
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：ProgramBody ] [ 输入符号：begin ]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<ProgramBody>
2019-06-21 08:00:36.714 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.Terminal@5a16b032[node=begin ,token=< (0,0), BEGIN, begin >], com.mytlx.compiler.syntax.symbol.NonTerminal@2428f565[node=StmList ,value=StmList], com.mytlx.compiler.syntax.symbol.Terminal@421e5078[node=end ,token=< (0,0), END, end >]]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建ProgramBody的子树：begin StmList end 
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是终结符：<BEGIN>
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 获取下一个Token：< (14,5), BEGIN, begin >
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 已匹配：< (14,5), BEGIN, begin >
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - ##########终结符识别完毕：<begin> ###########
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<StmList>
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (15,4), READ, read >
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：StmList ] [ 输入符号：read ]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<StmList>
2019-06-21 08:00:36.714 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@6e3482c9[node=Stm ,value=Stm], com.mytlx.compiler.syntax.symbol.NonTerminal@497d5334[node=StmMore ,value=StmMore]]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建StmList的子树：Stm StmMore 
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<Stm>
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (15,4), READ, read >
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：Stm ] [ 输入符号：read ]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<Stm>
2019-06-21 08:00:36.714 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@7541c0a4[node=InputStm ,value=InputStm]]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建Stm的子树：InputStm 
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<InputStm>
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (15,4), READ, read >
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：InputStm ] [ 输入符号：read ]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<InputStm>
2019-06-21 08:00:36.714 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.Terminal@449a716d[node=read ,token=< (0,0), READ, read >], com.mytlx.compiler.syntax.symbol.Terminal@4583d393[node=( ,token=< (0,0), LPAREN, ( >], com.mytlx.compiler.syntax.symbol.NonTerminal@542c4fa5[node=Invar ,value=Invar], com.mytlx.compiler.syntax.symbol.Terminal@738be429[node=) ,token=< (0,0), RPAREN, ) >]]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建InputStm的子树：read ( Invar ) 
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是终结符：<READ>
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 获取下一个Token：< (15,4), READ, read >
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 已匹配：< (15,4), READ, read >
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - ##########终结符识别完毕：<read> ###########
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是终结符：<LPAREN>
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 获取下一个Token：< (15,5), LPAREN, ( >
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 已匹配：< (15,5), LPAREN, ( >
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - ##########终结符识别完毕：<(> ###########
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<Invar>
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (15,6), ID, s >
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：Invar ] [ 输入符号：s ]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<Invar>
2019-06-21 08:00:36.714 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.Terminal@507a97e9[node=id ,token=< (0,0), ID, id >]]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建Invar的子树：id 
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是终结符：<ID>
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 获取下一个Token：< (15,6), ID, s >
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 已匹配：< (15,6), ID, s >
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - ##########终结符识别完毕：<s> ###########
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是终结符：<RPAREN>
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 获取下一个Token：< (15,7), RPAREN, ) >
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 已匹配：< (15,7), RPAREN, ) >
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - ##########终结符识别完毕：<)> ###########
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<StmMore>
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (15,8), SEMI, ; >
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：StmMore ] [ 输入符号：; ]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<StmMore>
2019-06-21 08:00:36.714 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.Terminal@738bf033[node=; ,token=< (0,0), SEMI, ; >], com.mytlx.compiler.syntax.symbol.NonTerminal@ae2196[node=StmList ,value=StmList]]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建StmMore的子树：; StmList 
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是终结符：<SEMI>
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 获取下一个Token：< (15,8), SEMI, ; >
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 已匹配：< (15,8), SEMI, ; >
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - ##########终结符识别完毕：<;> ###########
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<StmList>
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (16,6), ID, factor >
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：StmList ] [ 输入符号：factor ]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<StmList>
2019-06-21 08:00:36.714 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@c41eb79[node=Stm ,value=Stm], com.mytlx.compiler.syntax.symbol.NonTerminal@38d1f09d[node=StmMore ,value=StmMore]]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建StmList的子树：Stm StmMore 
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<Stm>
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (16,6), ID, factor >
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：Stm ] [ 输入符号：factor ]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<Stm>
2019-06-21 08:00:36.714 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.Terminal@55b0c153[node=id ,token=< (0,0), ID, id >], com.mytlx.compiler.syntax.symbol.NonTerminal@24fc70f2[node=AssCall ,value=AssCall]]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建Stm的子树：id AssCall 
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是终结符：<ID>
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 获取下一个Token：< (16,6), ID, factor >
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 已匹配：< (16,6), ID, factor >
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - ##########终结符识别完毕：<factor> ###########
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<AssCall>
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (16,7), LPAREN, ( >
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：AssCall ] [ 输入符号：( ]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<AssCall>
2019-06-21 08:00:36.714 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@3955a96e[node=CallStmRest ,value=CallStmRest]]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建AssCall的子树：CallStmRest 
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<CallStmRest>
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (16,7), LPAREN, ( >
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：CallStmRest ] [ 输入符号：( ]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<CallStmRest>
2019-06-21 08:00:36.714 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.Terminal@15885765[node=( ,token=< (0,0), LPAREN, ( >], com.mytlx.compiler.syntax.symbol.NonTerminal@2e86cad5[node=ActParamList ,value=ActParamList], com.mytlx.compiler.syntax.symbol.Terminal@5d1b750b[node=) ,token=< (0,0), RPAREN, ) >]]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建CallStmRest的子树：( ActParamList ) 
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是终结符：<LPAREN>
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 获取下一个Token：< (16,7), LPAREN, ( >
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 已匹配：< (16,7), LPAREN, ( >
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - ##########终结符识别完毕：<(> ###########
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<ActParamList>
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (16,8), ID, s >
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：ActParamList ] [ 输入符号：s ]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<ActParamList>
2019-06-21 08:00:36.714 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@4e06d0bc[node=Exp ,value=Exp], com.mytlx.compiler.syntax.symbol.NonTerminal@3c9d547a[node=ActParamMore ,value=ActParamMore]]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建ActParamList的子树：Exp ActParamMore 
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<Exp>
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (16,8), ID, s >
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：Exp ] [ 输入符号：s ]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<Exp>
2019-06-21 08:00:36.714 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@6df3cb6b[node=Term ,value=Term], com.mytlx.compiler.syntax.symbol.NonTerminal@6940e513[node=OtherTerm ,value=OtherTerm]]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建Exp的子树：Term OtherTerm 
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<Term>
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (16,8), ID, s >
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：Term ] [ 输入符号：s ]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<Term>
2019-06-21 08:00:36.714 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@4c17c426[node=Factor ,value=Factor], com.mytlx.compiler.syntax.symbol.NonTerminal@5f04ae7a[node=OtherFactor ,value=OtherFactor]]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建Term的子树：Factor OtherFactor 
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<Factor>
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (16,8), ID, s >
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：Factor ] [ 输入符号：s ]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<Factor>
2019-06-21 08:00:36.714 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@75152a55[node=Variable ,value=Variable]]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建Factor的子树：Variable 
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<Variable>
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (16,8), ID, s >
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：Variable ] [ 输入符号：s ]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<Variable>
2019-06-21 08:00:36.714 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.Terminal@2bd7d1e1[node=id ,token=< (0,0), ID, id >], com.mytlx.compiler.syntax.symbol.NonTerminal@789df6de[node=VariMore ,value=VariMore]]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建Variable的子树：id VariMore 
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是终结符：<ID>
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 获取下一个Token：< (16,8), ID, s >
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 已匹配：< (16,8), ID, s >
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - ##########终结符识别完毕：<s> ###########
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<VariMore>
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (16,9), COMMA, , >
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：VariMore ] [ 输入符号：, ]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<VariMore>
2019-06-21 08:00:36.714 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@2063fddf[node=blank ,value=blank]]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建VariMore的子树：blank 
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<OtherFactor>
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (16,9), COMMA, , >
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：OtherFactor ] [ 输入符号：, ]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<OtherFactor>
2019-06-21 08:00:36.714 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@78f8e6fc[node=blank ,value=blank]]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建OtherFactor的子树：blank 
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<OtherTerm>
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (16,9), COMMA, , >
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：OtherTerm ] [ 输入符号：, ]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<OtherTerm>
2019-06-21 08:00:36.714 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@29b334cc[node=blank ,value=blank]]
2019-06-21 08:00:36.714 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建OtherTerm的子树：blank 
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<ActParamMore>
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (16,9), COMMA, , >
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：ActParamMore ] [ 输入符号：, ]
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<ActParamMore>
2019-06-21 08:00:36.730 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.Terminal@5f7820fb[node=, ,token=< (0,0), COMMA, , >], com.mytlx.compiler.syntax.symbol.NonTerminal@533650a5[node=ActParamList ,value=ActParamList]]
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建ActParamMore的子树：, ActParamList 
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是终结符：<COMMA>
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 获取下一个Token：< (16,9), COMMA, , >
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 已匹配：< (16,9), COMMA, , >
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - ##########终结符识别完毕：<,> ###########
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<ActParamList>
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (16,10), ID, t >
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：ActParamList ] [ 输入符号：t ]
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<ActParamList>
2019-06-21 08:00:36.730 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@2fb7f404[node=Exp ,value=Exp], com.mytlx.compiler.syntax.symbol.NonTerminal@36f264b6[node=ActParamMore ,value=ActParamMore]]
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建ActParamList的子树：Exp ActParamMore 
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<Exp>
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (16,10), ID, t >
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：Exp ] [ 输入符号：t ]
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<Exp>
2019-06-21 08:00:36.730 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@553fdd12[node=Term ,value=Term], com.mytlx.compiler.syntax.symbol.NonTerminal@229385f9[node=OtherTerm ,value=OtherTerm]]
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建Exp的子树：Term OtherTerm 
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<Term>
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (16,10), ID, t >
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：Term ] [ 输入符号：t ]
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<Term>
2019-06-21 08:00:36.730 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@c613acc[node=Factor ,value=Factor], com.mytlx.compiler.syntax.symbol.NonTerminal@39ba26ca[node=OtherFactor ,value=OtherFactor]]
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建Term的子树：Factor OtherFactor 
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<Factor>
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (16,10), ID, t >
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：Factor ] [ 输入符号：t ]
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<Factor>
2019-06-21 08:00:36.730 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@767cc856[node=Variable ,value=Variable]]
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建Factor的子树：Variable 
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<Variable>
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (16,10), ID, t >
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：Variable ] [ 输入符号：t ]
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<Variable>
2019-06-21 08:00:36.730 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.Terminal@5f5db1c4[node=id ,token=< (0,0), ID, id >], com.mytlx.compiler.syntax.symbol.NonTerminal@304a6e74[node=VariMore ,value=VariMore]]
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建Variable的子树：id VariMore 
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是终结符：<ID>
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 获取下一个Token：< (16,10), ID, t >
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 已匹配：< (16,10), ID, t >
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - ##########终结符识别完毕：<t> ###########
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<VariMore>
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (16,11), RPAREN, ) >
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：VariMore ] [ 输入符号：) ]
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<VariMore>
2019-06-21 08:00:36.730 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@390bc36a[node=blank ,value=blank]]
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建VariMore的子树：blank 
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<OtherFactor>
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (16,11), RPAREN, ) >
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：OtherFactor ] [ 输入符号：) ]
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<OtherFactor>
2019-06-21 08:00:36.730 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@3d1f105[node=blank ,value=blank]]
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建OtherFactor的子树：blank 
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<OtherTerm>
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (16,11), RPAREN, ) >
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：OtherTerm ] [ 输入符号：) ]
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<OtherTerm>
2019-06-21 08:00:36.730 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@3f07f9da[node=blank ,value=blank]]
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建OtherTerm的子树：blank 
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<ActParamMore>
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (16,11), RPAREN, ) >
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：ActParamMore ] [ 输入符号：) ]
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<ActParamMore>
2019-06-21 08:00:36.730 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@b34da4e[node=blank ,value=blank]]
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建ActParamMore的子树：blank 
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是终结符：<RPAREN>
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 获取下一个Token：< (16,11), RPAREN, ) >
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 已匹配：< (16,11), RPAREN, ) >
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - ##########终结符识别完毕：<)> ###########
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<StmMore>
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (16,12), SEMI, ; >
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：StmMore ] [ 输入符号：; ]
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<StmMore>
2019-06-21 08:00:36.730 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.Terminal@505f41fd[node=; ,token=< (0,0), SEMI, ; >], com.mytlx.compiler.syntax.symbol.NonTerminal@15809fb8[node=StmList ,value=StmList]]
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建StmMore的子树：; StmList 
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是终结符：<SEMI>
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 获取下一个Token：< (16,12), SEMI, ; >
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 已匹配：< (16,12), SEMI, ; >
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - ##########终结符识别完毕：<;> ###########
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<StmList>
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (17,5), WRITE, write >
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：StmList ] [ 输入符号：write ]
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<StmList>
2019-06-21 08:00:36.730 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@6458d9d2[node=Stm ,value=Stm], com.mytlx.compiler.syntax.symbol.NonTerminal@5990a21f[node=StmMore ,value=StmMore]]
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建StmList的子树：Stm StmMore 
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<Stm>
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (17,5), WRITE, write >
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：Stm ] [ 输入符号：write ]
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<Stm>
2019-06-21 08:00:36.730 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@17102cca[node=OutputStm ,value=OutputStm]]
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建Stm的子树：OutputStm 
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<OutputStm>
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (17,5), WRITE, write >
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：OutputStm ] [ 输入符号：write ]
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<OutputStm>
2019-06-21 08:00:36.730 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.Terminal@6753e1da[node=write ,token=< (0,0), WRITE, write >], com.mytlx.compiler.syntax.symbol.Terminal@218087d0[node=( ,token=< (0,0), LPAREN, ( >], com.mytlx.compiler.syntax.symbol.NonTerminal@4f73476e[node=Exp ,value=Exp], com.mytlx.compiler.syntax.symbol.Terminal@1cc310b6[node=) ,token=< (0,0), RPAREN, ) >]]
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建OutputStm的子树：write ( Exp ) 
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是终结符：<WRITE>
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 获取下一个Token：< (17,5), WRITE, write >
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 已匹配：< (17,5), WRITE, write >
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - ##########终结符识别完毕：<write> ###########
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是终结符：<LPAREN>
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 获取下一个Token：< (17,6), LPAREN, ( >
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 已匹配：< (17,6), LPAREN, ( >
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - ##########终结符识别完毕：<(> ###########
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<Exp>
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (17,7), ID, t >
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：Exp ] [ 输入符号：t ]
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<Exp>
2019-06-21 08:00:36.730 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@5396ffd[node=Term ,value=Term], com.mytlx.compiler.syntax.symbol.NonTerminal@20390583[node=OtherTerm ,value=OtherTerm]]
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建Exp的子树：Term OtherTerm 
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<Term>
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (17,7), ID, t >
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：Term ] [ 输入符号：t ]
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<Term>
2019-06-21 08:00:36.730 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@71d7a177[node=Factor ,value=Factor], com.mytlx.compiler.syntax.symbol.NonTerminal@4446eae1[node=OtherFactor ,value=OtherFactor]]
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建Term的子树：Factor OtherFactor 
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<Factor>
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (17,7), ID, t >
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：Factor ] [ 输入符号：t ]
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<Factor>
2019-06-21 08:00:36.730 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@4cf2803a[node=Variable ,value=Variable]]
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建Factor的子树：Variable 
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<Variable>
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (17,7), ID, t >
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：Variable ] [ 输入符号：t ]
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<Variable>
2019-06-21 08:00:36.730 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.Terminal@4ce7ce88[node=id ,token=< (0,0), ID, id >], com.mytlx.compiler.syntax.symbol.NonTerminal@10d616bf[node=VariMore ,value=VariMore]]
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建Variable的子树：id VariMore 
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是终结符：<ID>
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 获取下一个Token：< (17,7), ID, t >
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 已匹配：< (17,7), ID, t >
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - ##########终结符识别完毕：<t> ###########
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<VariMore>
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (17,8), RPAREN, ) >
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：VariMore ] [ 输入符号：) ]
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<VariMore>
2019-06-21 08:00:36.730 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@506e3c6e[node=blank ,value=blank]]
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建VariMore的子树：blank 
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<OtherFactor>
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (17,8), RPAREN, ) >
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：OtherFactor ] [ 输入符号：) ]
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<OtherFactor>
2019-06-21 08:00:36.730 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@479fb0bf[node=blank ,value=blank]]
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建OtherFactor的子树：blank 
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<OtherTerm>
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (17,8), RPAREN, ) >
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：OtherTerm ] [ 输入符号：) ]
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<OtherTerm>
2019-06-21 08:00:36.730 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@3c93017b[node=blank ,value=blank]]
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建OtherTerm的子树：blank 
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是终结符：<RPAREN>
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 获取下一个Token：< (17,8), RPAREN, ) >
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 已匹配：< (17,8), RPAREN, ) >
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - ##########终结符识别完毕：<)> ###########
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是非终结符：<StmMore>
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 当前Token是< (18,3), END, end >
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 查询预测分析表：[ 非终结符：StmMore ] [ 输入符号：end ]
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - NON_TERMINAL：<StmMore>
2019-06-21 08:00:36.730 [INFO ] com.mytlx.compiler.syntax.LL1.LL1Parse - 预测分析表返回：[com.mytlx.compiler.syntax.symbol.NonTerminal@e18e5a[node=blank ,value=blank]]
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - 构建StmMore的子树：blank 
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是终结符：<END>
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 获取下一个Token：< (18,3), END, end >
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 已匹配：< (18,3), END, end >
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - ##########终结符识别完毕：<end> ###########
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - symbol是终结符：<EOF>
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 获取下一个Token：< (18,4), EOF, . >
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LexParse - 已匹配：< (18,4), EOF, . >
2019-06-21 08:00:36.730 [TRACE] com.mytlx.compiler.syntax.LL1.LL1Parse - ##########终结符识别完毕：<.> ###########
